---
authors: ["brice.dutheil"]
date: "2020-05-24T01:54:58+02:00"
language: en
draft: true
#tags: ["jfr","profiling","java flight recorder", "java"]
slug: "using-java-flight-recorder-and-jdk-mission-control"
title: "Using Java FlightRecorder and JDK Mission Control"
#series: ["Flight Recorder"]
#_build:
#  list: never
---




////
https://docs.oracle.com/en/java/javase/11/troubleshoot/diagnostic-tools.html[Official Troubleshooting guide for Java 11]

https://blogs.oracle.com/javamagazine/java-flight-recorder-and-jfr-event-streaming-in-java-14


https://daniel.mitterdorfer.name/talks/2017/Java%20Flight%20Recorder.pdf
https://www.dariawan.com/tutorials/java/java-11-flight-recorder-jep-328/

https://github.com/lhotari/jfr-report-tool

https://github.com/thegreystone/jmc-tutorial

.Talks
https://www.youtube.com/watch?v=E9K5m1HXMSc&list=WL&index=21&t=0s
https://www.youtube.com/watch?v=_69wTZR6lis&list=WL&index=22&t=0s
https://www.infoq.com/presentations/monitoring-jdk-jfr/[Continuous Monitoring with JDK Flight Recorder (JFR)]


http://hirt.se/blog/?p=1055[Solving Memory Leaks without Heap Dumps]

https://www.slideshare.net/PoonamBajaj5/jfr-174014342[CodeOne 2019 presentation on JFR]
https://www.slideshare.net/koduki/performance-monitoring-with-java-flight-recorder-on-openjdk-dev2406[Performance Monitoring with Java Flight Recorder on OpenJDK [DEV2406] ]



https://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html[Why (Most) Sampling Java Profilers Are Fucking Terrible]
https://psy-lob-saw.blogspot.com/2015/12/safepoints.html[Safepoints: Meaning, Side Effects and Overheads]
https://psy-lob-saw.blogspot.com/2016/06/the-pros-and-cons-of-agct.html[The Pros and Cons of AsyncGetCallTrace Profilers]
////


Java Flight Recorder, the profiler you can use in production, continuously.
Flight Recorder has been available before in the JDK, e.g. it shipped as part of the JDK 8,
but to use it, it demanded a to set specific commercial VM flags to unlock
FlightRecorder, this is not anymore necessary with Java 11.

NOTE: This page assumes JDK 11, that means there is no need to set
`-XX:+UnlockCommercialFeatures`, `-XX:+FlightRecorder` flags. Or more particular to JFR
 the use of `-XX:+UnlockDiagnosticVMOptions` and `-XX:+DebugNonSafepoints` https://github.com/openjdk/jmc/blob/bacb448fd4ed1a9a5d887c50aebff4e854d3512a/core/org.openjdk.jmc.common/src/main/java/org/openjdk/jmc/common/version/JavaVersionSupport.java#L59-L60[source]

////
Cannot find public access to JDK-8036749, the only reference found by google is
https://bugs.openjdk.java.net/browse/JMC-6554
////

TIP: Also this article uses a lot the https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE[`JDK_JAVA_OPTIONS`]
environment variable.

== Brief introduction to Java Flight Recorder

Flight Recorder is a feature backed in the JVM that *traces* what's happening inside the JVM with *events*.
FlightRecorder development started a long time ago in the early 2000 in a company name BEA, for their own
JVM implementation, JRockit. Oracle acquired BEA, then acquired Sun, and merged the source of JRockit to Hotspot.

At some BEA engineers needed insight in their JVM, in production, logging was not an option as it had too much
overhead, so they designed an event based system to work in production.

JDK Mission Control on the other end is a software that will analyze these events and build consolidated views
for us to analyze.

JFR with JDK Mission Control together are similar to system architectured as
https://martinfowler.com/eaaDev/EventSourcing.html[_Event Sourcing_] system.


.JFR big picture
image::../../static/assets/jfr/java-flight-recorder-big-picture.svg[align="center"]


=== How to start a recording ?

One of the first interesting thing you can do is to start a recording at runtime ;
`jcmd` is the tool for this job, it's the Swiss Army knife tool for to service your Java app.
If you don't know it, use it's great !

Prior Java 11 FlightRecorder had to be enabled before. Now it's not anymore necessary
it's possible to _start_ a JFR session.

.FlightRecorder is on by default
[source, bash]
----
$ jcmd $(pgrep java) VM.flags -all | grep FlightRecorder
     bool FlightRecorder                           = true                                      {product} {management}
    ccstr FlightRecorderOptions                    =                                           {product} {default}
----

Just runt `JFR.start` on the running java pid.

[source,bash]
----
$ jcmd $(pidof java) JFR.start
6:
Started recording 2. No limit specified, using maxsize=250MB as default.

Use jcmd 6 JFR.dump name=2 filename=FILEPATH to copy recording data to file.
----

The output guides the user to the next useful commands, in particular `JFR.dump`.
Also, this commands tells you that a recording by default is limited to 250Mb.
`jcmd` provides an `help` command that describes document for each command options.

.JFR.start example
[source, bash, role="primary"]
----
$ jcmd $(pgrep java) JFR.start \
  name=app-profile \
  duration=300s \
  filename=/tmp/app-profile-$(date +%FT%H-%M-%S).jfr \
  settings=profile
6:
Started recording 2. The result will be written to:

/tmp/app-profile-2020-03-26T16-41-48.jfr
----

.JFR.start help
[source, bash, role="secondary"]
----
$ jcmd $(pgrep java) help JFR.start
6:
JFR.start
Starts a new JFR recording

Impact: Medium: Depending on the settings for a recording, the impact can range from low to high.

Permission: java.lang.management.ManagementPermission(monitor)

Syntax : JFR.start [options]

Options: (options must be specified using the <key> or <key>=<value> syntax)
	name : [optional] Name that can be used to identify recording, e.g. \"My Recording\" (STRING, no default value)
	settings : [optional] Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING SET, no default value)
	delay : [optional] Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h. (NANOTIME, 0)
	duration : [optional] Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s. (NANOTIME, 0)
	disk : [optional] Recording should be persisted to disk (BOOLEAN, no default value)
	filename : [optional] Resulting recording filename, e.g. \"/home/user/My Recording.jfr\" (STRING, no default value)
	maxage : [optional] Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit (NANOTIME, 0)
	maxsize : [optional] Maximum amount of bytes to keep (on disk) in (k)B, (M)B or (G)B, e.g. 500M, or 0 for no limit (MEMORY SIZE, 0)
	dumponexit : [optional] Dump running recording when JVM shuts down (BOOLEAN, no default value)
	path-to-gc-roots : [optional] Collect path to GC roots (BOOLEAN, false)
----

In production you'll be most likely using `duration`, `maxsize`, `filename` and `settings` options.
We'll briefly look at other JFR commands after discussing the `settings`.

NOTE: Later in this article we'll see how to start recording from the command line
using `-XX:StartFlightRecording`.

=== Setting files

The `settings` option refers to a configuration of the FlightRecorder,
the JDK ships with two : `default` and `profile`. A configuration is an XML file, with
`event` elements that describe how JFR in the JVM will handle events, if they
are enabled, their threshold, if stacktraces are recorded, etc. And there is also a
`control` element that is used by JDK Mission Control.

Here's is the first few line of the `default` settings. As its name impies, this is the configuration
that is used when the command is run without a `settings` option.

./usr/lib/jvm/java-11-amazon-corretto/lib/jfr/default.jfc
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<!--
     Recommended way to edit .jfc files is to use Java Mission Control,
     see Window -> Flight Recorder Template Manager.
-->

<configuration version="2.0"
               label="Continuous"
               description="Low overhead configuration safe for continuous use in production environments, typically less than 1 % overhead."
               provider="Oracle">

    <event name="jdk.ThreadAllocationStatistics">
      <setting name="enabled">true</setting>
      <setting name="period">everyChunk</setting>
    </event>

    <!-- a lot more events -->

    <!-- then the control element -->
</configuration>
----

In terms of file size magnitude on a pretty busy web application server using the `default` settings and for a
duration of 5 minutes, the resulting dumped file weighs 15 MiB. With this profile you'll get more than
basic information, IO, GC events, locking behavior, thread events, method profiling, etc.

The announced overhead is maximum 1% !

./usr/lib/jvm/java-11-amazon-corretto/lib/jfr/profile.jfc
[source, xml]
----
<!--
     Recommended way to edit .jfc files is to use Java Mission Control,
     see Window -> Flight Recorder Template Manager.
-->

<configuration version="2.0"
               label="Profiling"
               description="Low overhead configuration for profiling, typically around 2 % overhead."
               provider="Oracle">

    <event name="jdk.ThreadAllocationStatistics">
      <setting name="enabled">true</setting>
      <setting name="period">everyChunk</setting>
    </event>

    <!-- a lot more event -->
</configuration>
----

With the `profile` settings, the dumped file takes around 35mb for a 5min duration. And it will
get access to additional events like the `OldObjectSample` stacktraces, or TLS events
like TLS handshakes, X509 validation, Classloading events, etc.

It actually has a tad more overhead, 2%. But in most workload this should be ok.

To value of the `settings` option is file name of these files `default` or `profile`. In addition
it's also possible to pass an absolute file path, in other words it's possible to use configuration
of our own stored elsewhere.

=== Dumping a recording

If it's needed to acquire the recording, it's possible to dump it at anytime.

.JFR.dump example
[source, bash, role="primary"]
----
$ jcmd $(pidof java) JFR.dump filename=/tmp/app-profile-$(date +%FT%H-%M-%S).jfr
6:
Dumped recording, 239.5 MB written to:

/tmp/app-profile-2020-06-26T15-16-57.jfr
----

.JFR.dump help
[source, bash, role="secondary"]
----
$ jcmd $(pgrep java) help JFR.dump
6:
JFR.dump
Copies contents of a JFR recording to file. Either the name or the recording id must be specified.

Impact: Low

Permission: java.lang.management.ManagementPermission(monitor)

Syntax : JFR.dump [options]

Options: (options must be specified using the <key> or <key>=<value> syntax)
	name : [optional] Recording name, e.g. \"My Recording\" (STRING, no default value)
	filename : [optional] Copy recording data to file, e.g. \"/home/user/My Recording.jfr\" (STRING, no default value)
	maxage : [optional] Maximum duration to dump, in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit (NANOTIME, 0)
	maxsize : [optional] Maximum amount of bytes to dump, in (M)B or (G)B, e.g. 500M, or 0 for no limit (MEMORY SIZE, 0)
	begin : [optional] Point in time to dump data from, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d (STRING, no default value)
	end : [optional] Point in time to dump data to, e.g. 09:00, 21:35:00, 2018-06-03T18:12:56.827Z, 2018-06-03T20:13:46.832, -10m, -3h, or -1d (STRING, no default value)
	path-to-gc-roots : [optional] Collect path to GC roots (BOOLEAN, false)
----

If there is a single recording at the time it's possible to just use `JFR.dump`, but JFR is
powerful enough to support multiple concomitant recordings, in this case you need to specify
which recording to dump, obviously.
Some of the options override those defined in the start command like `filename` or `maxage`
for the current dump in particular. THe other options are certainly interesting but
I found them a bit less useful in practice.

=== Details of the active recording(s)

If they are multiple active recordings or if it's necessary to check the event configuration
of the active recording `jcmd` comes with the `JFR.check`.

.JFR.check example
[source, bash, role="primary"]
----
$ jcmd $(pgrep java) JFR.check
6:
Recording 2: name=2 maxsize=250.0MB (running)
----

.JFR.check help
[source, bash]
----
$ jcmd $(pgrep java) help JFR.check
6:
JFR.check
Checks running JFR recording(s)

Impact: Low

Permission: java.lang.management.ManagementPermission(monitor)

Syntax : JFR.check [options]

Options: (options must be specified using the <key> or <key>=<value> syntax)
	name : [optional] Recording name, e.g. \"My Recording\" or omit to see all recordings (STRING, no default value)
	verbose : [optional] Print event settings for the recording(s) (BOOLEAN, false)
----

The `verbose` option allows examining which event are enabled for a recording.

=== Stopping a active recording

When the recording session is deemed over, then one can stop it providing a different
file name than the one set in the start command.

.JFR.stop example
[source, bash, role="primary"]
----
$ jcmd $(pgrep java) JFR.stop \
  name=app-profile \
  filename=/tmp/app-profile-$(date +%FT%H-%M-%S).jfr
----

.JFR.stop help
[source, bash, role="secondary"]
----
$ jcmd $(pgrep java) help JFR.stop
6:
JFR.stop
Stops a JFR recording

Impact: Low

Permission: java.lang.management.ManagementPermission(monitor)

Syntax : JFR.stop [options]

Options: (options must be specified using the <key> or <key>=<value> syntax)
	name :  Recording text,.e.g \"My Recording\" (STRING, no default value)
	filename : [optional] Copy recording data to file, e.g. \"/home/user/My Recording.jfr\" (STRING, no default value)
----

=== System Flight Recorder configuration

What we saw before is how to start a recording and how to configure this specific recording.
But there is another class of options that modifies aspects of the JFR internals.
As a reminder those affects all recording in some way.

.JFR.configure example
[source, bash, role="primary"]
----
$ jcmd $(pidof java) JFR.configure \
  stackdepth=96 \
  repositorypath=/tmp/jfr-repo
6:
Repository path: /tmp/jfr-repo/2020_06_26_16_01_58_6

Dump path: /gclogs

Stack depth: 96

$ jcmd $(pidof java) JFR.configure
6:
Current configuration:

Repository path: /tmp/jfr-repo/2020_06_26_16_03_41_6

Stack depth: 96
Global buffer count: 20
Global buffer size: 512.0 kB
Thread buffer size: 8.0 kB
Memory size: 10.0 MB
Max chunk size: 12.0 MB
Sample threads: true
----

.JFR.configure help
[source, bash, role="secondary"]
----
$ jcmd $(pidof java) help JFR.configure
80657:
JFR.configure
Configure JFR

Impact: Low

Permission: java.lang.management.ManagementPermission(monitor)

Syntax : JFR.configure [options]

Options: (options must be specified using the <key> or <key>=<value> syntax)
	repositorypath : [optional] Path to repository,.e.g \"My Repository\" (STRING, no default value)
	dumppath : [optional] Path to dump,.e.g \"My Dump path\" (STRING, no default value)
	stackdepth : [optional] Stack Depth (JULONG, 64)
	globalbuffercount : [optional] Number of global buffers, (JULONG, 20)
	globalbuffersize : [optional] Size of a global buffers, (MEMORY SIZE, 512k)
	thread_buffer_size : [optional] Size of a thread buffer (MEMORY SIZE, 8k)
	memorysize : [optional] Overall memory size,  (MEMORY SIZE, 10m)
	maxchunksize : [optional] Size of an individual disk chunk (MEMORY SIZE, 12m)
	samplethreads : [optional] Activate Thread sampling (BOOLEAN, true)
----

Here I'm increasing the `stackdepth`, this might be useful to generate more accurate flamegraphs,
or for some other analysis like with the `OldObjectSample`.

The `repositorypath` is where JFR dumps regularly slices or chunks of jfr events, they have
maximum size of `maxchunksize`. These files behave like a log rolling appender.
By default these chunks are stored in the temporary directory and in a subfolder with a timestamp.

.JFR repository
[source, bash]
----
$ ls -lah /tmp/jfr-repo/2020_06_26_16_03_41_6/
total 71M
drwxr-xr-x 2 43514 root 4.0K Jun 26 16:21 .
drwxr-xr-x 3 43514 root 4.0K Jun 26 16:03 ..
-rw-r--r-- 1 43514 root 2.4M Jun 26 16:04 2020_06_26_16_04_02.jfr
-rw-r--r-- 1 43514 root 3.6M Jun 26 16:04 2020_06_26_16_04_12.jfr
-rw-r--r-- 1 43514 root  18M Jun 26 16:10 2020_06_26_16_04_47.jfr
-rw-r--r-- 1 43514 root 2.5M Jun 26 16:10 2020_06_26_16_10_18.jfr
-rw-r--r-- 1 43514 root  19M Jun 26 16:16 2020_06_26_16_10_26.jfr
-rw-r--r-- 1 43514 root  18M Jun 26 16:21 2020_06_26_16_16_16.jfr
-rw-r--r-- 1 43514 root    0 Jun 26 16:21 2020_06_26_16_21_50.jfr
-rw-r--r-- 1 43514 root 8.7M Jun 26 16:25 2020_06_26_16_21_50.part
----

_I'm not sure why some chunks are over 12M (the default chunk size) at this time._

Careful however as some of these options are not well documented, and may not expose
what we'd expect, e.g. `dumppath` only affects dump created when the app crashes and only
if the `dumponexit` recording option is true.

NOTE: These options are also available at startup via `-XX:FlightRecorderOptions`,
we'll see later how to use this option.


== Analyze with `jfr`

Now to exploit the recording, we have a tool named `jfr` that ships with the JDK.
On Linux the _alternative_ jdk management may not be aware of `jfr`, which means
you may need to use the full path to this executable.

The first interesting thing to do is to get an overview of the recording,
the `summary` sub-command displays an histogram of the events.

.events type histogram (summary)
[source, bash]
----
$ jfr summary /tmp/app-profile-2020-03-26T16-57-14.jfr

 Version: 2.0
 Chunks: 1
 Start: 2020-03-26 16:57:14 (UTC)
 Duration: 303 s

 Event Type                            Count  Size (bytes)
===========================================================
 jdk.ThreadPark                       130278       5868710
 jdk.SocketRead                        38804       1934842
 jdk.JavaMonitorWait                   38722       1378513
 jdk.NativeMethodSample                14702        263403
 jdk.ThreadCPULoad                     11821        271763
 jdk.ExecutionSample                    3010         54177
 jdk.ModuleExport                       2505         40187
 jdk.ClassLoaderStatistics              2344         72694
 jdk.ThreadAllocationStatistics          878         16962
 jdk.ModuleRequire                       754         11964
 jdk.BooleanFlag                         648         23106
 jdk.CPULoad                             298          7450
 jdk.JavaThreadStatistics                298          6258
 jdk.ClassLoadingStatistics              298          5066
 jdk.CompilerStatistics                  298         11324
 jdk.ExceptionStatistics                 298          6258
 jdk.ActiveSetting                       285         10497
 jdk.BiasedLockRevocation                275          7831
 jdk.NativeLibrary                       252         18564
 jdk.LongFlag                            229          8875
 jdk.UnsignedLongFlag                    182          7168
 jdk.InitialEnvironmentVariable          167         10243
 jdk.NetworkUtilization                  120          2640
 jdk.TenuringDistribution                 75          1437
 jdk.ThreadContextSwitchRate              30           510
 jdk.ThreadSleep                          29           696
 jdk.StringFlag                           26           880
 jdk.GCPhasePauseLevel2                   25          1080
 jdk.InitialSystemProperty                23          1316
 jdk.MetaspaceChunkFreeListSummary        20           520
 jdk.GCReferenceStatistics                20           350
 jdk.GCPhasePauseLevel1                   20           965
 jdk.CheckPoint                           17       1631868
 jdk.ExecuteVMOperation                   15           391
 jdk.DoubleFlag                           13           618
 jdk.BiasedLockClassRevocation            10           275
 jdk.GCHeapSummary                        10           475
 jdk.MetaspaceSummary                     10           580
 jdk.G1HeapSummary                        10           300
 jdk.OldObjectSample                      10           367
 jdk.UnsignedIntFlag                       8           300
 jdk.CodeCacheStatistics                   6           232
 jdk.ThreadStart                           6           102
 jdk.GarbageCollection                     5           145
 jdk.YoungGarbageCollection                5           100
 jdk.G1GarbageCollection                   5           100
 jdk.G1MMU                                 5           100
 jdk.EvacuationInformation                 5           185
 jdk.G1EvacuationYoungStatistics           5           160
 jdk.G1EvacuationOldStatistics             5           152
 jdk.G1BasicIHOP                           5           243
 jdk.G1AdaptiveIHOP                        5           240
 jdk.GCPhasePause                          5           150
 jdk.IntFlag                               3           107
 jdk.BiasedLockSelfRevocation              2            45
 jdk.PhysicalMemory                        2            46
 jdk.ThreadDump                            2       1389568
 jdk.CodeSweeperStatistics                 2            64
 jdk.GCConfiguration                       2            60
 jdk.ThreadEnd                             1            17
 jdk.Metadata                              1         74738
 jdk.JavaMonitorEnter                      1            33
 jdk.SafepointBegin                        1            24
 jdk.JVMInformation                        1           898
 jdk.OSInformation                         1           367
 jdk.VirtualizationInformation             1            33
 jdk.CPUInformation                        1          1432
 jdk.CPUTimeStampCounter                   1            25
 jdk.CompilerConfiguration                 1            15
 jdk.CodeCacheConfiguration                1            51
 jdk.CodeSweeperConfiguration              1            15
 jdk.GCSurvivorConfiguration               1            15
 jdk.GCTLABConfiguration                   1            17
 jdk.GCHeapConfiguration                   1            31
 jdk.YoungGenerationConfiguration          1            22
 jdk.ActiveRecording                       1            87
 jdk.JavaMonitorInflate                    0             0
 jdk.ReservedStackActivation               0             0
 jdk.ClassLoad                             0             0
 jdk.ClassDefine                           0             0
 jdk.ClassUnload                           0             0
 jdk.IntFlagChanged                        0             0
 jdk.UnsignedIntFlagChanged                0             0
 jdk.LongFlagChanged                       0             0
 jdk.UnsignedLongFlagChanged               0             0
 jdk.DoubleFlagChanged                     0             0
 jdk.BooleanFlagChanged                    0             0
 jdk.StringFlagChanged                     0             0
 jdk.MetaspaceGCThreshold                  0             0
 jdk.MetaspaceAllocationFailure            0             0
 jdk.MetaspaceOOM                          0             0
 jdk.PSHeapSummary                         0             0
 jdk.ParallelOldGarbageCollection          0             0
 jdk.OldGarbageCollection                  0             0
 jdk.ObjectCountAfterGC                    0             0
 jdk.PromoteObjectInNewPLAB                0             0
 jdk.PromoteObjectOutsidePLAB              0             0
 jdk.PromotionFailed                       0             0
 jdk.EvacuationFailed                      0             0
 jdk.ConcurrentModeFailure                 0             0
 jdk.GCPhasePauseLevel3                    0             0
 jdk.GCPhasePauseLevel4                    0             0
 jdk.GCPhaseConcurrent                     0             0
 jdk.AllocationRequiringGC                 0             0
 jdk.G1HeapRegionTypeChange                0             0
 jdk.Compilation                           0             0
 jdk.CompilerPhase                         0             0
 jdk.CompilationFailure                    0             0
 jdk.CompilerInlining                      0             0
 jdk.SweepCodeCache                        0             0
 jdk.CodeCacheFull                         0             0
 jdk.SafepointStateSynchronization         0             0
 jdk.SafepointWaitBlocked                  0             0
 jdk.SafepointCleanup                      0             0
 jdk.SafepointCleanupTask                  0             0
 jdk.SafepointEnd                          0             0
 jdk.Shutdown                              0             0
 jdk.ObjectAllocationInNewTLAB             0             0
 jdk.ObjectAllocationOutsideTLAB           0             0
 jdk.DumpReason                            0             0
 jdk.DataLoss                              0             0
 jdk.SystemProcess                         0             0
 jdk.X509Validation                        0             0
 jdk.ObjectCount                           0             0
 jdk.G1HeapRegionInformation               0             0
 jdk.ZPageAllocation                       0             0
 jdk.ZThreadPhase                          0             0
 jdk.ZStatisticsCounter                    0             0
 jdk.ZStatisticsSampler                    0             0
 jdk.FileForce                             0             0
 jdk.FileRead                              0             0
 jdk.FileWrite                             0             0
 jdk.SocketWrite                           0             0
 jdk.JavaExceptionThrow                    0             0
 jdk.JavaErrorThrow                        0             0
 jdk.SecurityPropertyModification          0             0
 jdk.X509Certificate                       0             0
 jdk.TLSHandshake                          0             0
----

But other interesting things could be done using this tool.
The `print` subcomand can extract these events, like in json, from there
it's possible to perform other type of aggregation.

.extract data from using `jfr` and `jq`
[source, bash]
----
$ jfr print \
  --json \
  --events jdk.ThreadPark \
  /gclogs/startup.jfr \
  | jq '.recording.events[] | .values.duration'
----

It's also possible to assemble `jfr` files or break them in smaller parts.
By the way the files in the _repository_ can be exploited this way.
Keep in mind these files may be removed as soon as they are expired or as
soon as every recording stops.

.summary on a chunk in the repository
[source, bash]
----
$ jfr summary /tmp/jfr-repo/2020_06_26_16_03_41_6/2020_06_26_16_04_12.jfr
Version: 2.0
Chunks: 1
Start: 2020-06-26 16:04:12 (UTC)
Duration: 35 s

 Event Type                            Count  Size (bytes)
===========================================================
 jdk.ThreadPark                        19853        918218
 jdk.SocketRead                         6459        325796
 jdk.JavaMonitorWait                    5581        200005
 jdk.ClassLoaderStatistics              2620         81098
...
----

Although `jfr` is a nice tool a which you can build upon, the next section
presents the other elephant in the room (in a positive way), JDK Mission Control
which empowers its user with remarkable diagnosis skills.

== JDK Mission Control
Then analyze the file in JDK Mission Control, (e.g. the one from `brew cask install jdk-mission-control`)


It's also possible to get very qui information using the `jfr` command line tool
(which is not always exported a symlink)


https://docs.oracle.com/en/java/javase/11/troubleshoot/diagnostic-tools.html#GUID-7E8058D0-249E-44DB-8714-3AA9DA6A4DB8

=== Memory LEaks

https://docs.oracle.com/en/java/javase/11/troubleshoot/troubleshoot-memory-leaks.html#GUID-8090B138-6E0C-4926-9659-BE739062AB75

=== Performance Issues

https://docs.oracle.com/en/java/javase/11/troubleshoot/troubleshoot-performance-issues-using-jfr.html#GUID-0FE29092-18B5-4BEB-8D8D-0CBA7A4FEA1D


// TODO options of -XX:StartFlightRecording, see https://www.dariawan.com/tutorials/java/java-11-flight-recorder-jep-328/
Finding the options

Un practical to have meaningful help from the usual
`java -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal -version`, I found that
using `jcmd` to be quite useful to help me pass arguments to `-XX:StartFlightRecording`.

[source]
----
❯ jcmd 90091 VM.version
90091:
OpenJDK 64-Bit Server VM version 11.0.7+10-LTS
JDK 11.0.7
❯ jcmd 90091 help JFR.start
90091:
JFR.start
Starts a new JFR recording

Impact: Medium: Depending on the settings for a recording, the impact can range from low to high.

Permission: java.lang.management.ManagementPermission(monitor)

Syntax : JFR.start [options]

Options: (options must be specified using the <key> or <key>=<value> syntax)
       name : [optional] Name that can be used to identify recording, e.g. \"My Recording\" (STRING, no default value)
       settings : [optional] Settings file(s), e.g. profile or default. See JRE_HOME/lib/jfr (STRING SET, no default value)
       delay : [optional] Delay recording start with (s)econds, (m)inutes), (h)ours), or (d)ays, e.g. 5h. (NANOTIME, 0)
       duration : [optional] Duration of recording in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 300s. (NANOTIME, 0)
       disk : [optional] Recording should be persisted to disk (BOOLEAN, no default value)
       filename : [optional] Resulting recording filename, e.g. \"/Users/user/My Recording.jfr\" (STRING, no default value)
       maxage : [optional] Maximum time to keep recorded data (on disk) in (s)econds, (m)inutes, (h)ours, or (d)ays, e.g. 60m, or 0 for no limit (NANOTIME, 0)
       maxsize : [optional] Maximum amount of bytes to keep (on disk) in (k)B, (M)B or (G)B, e.g. 500M, or 0 for no limit (MEMORY SIZE, 0)
       dumponexit : [optional] Dump running recording when JVM shuts down (BOOLEAN, no default value)
       path-to-gc-roots : [optional] Collect path to GC roots (BOOLEAN, false)
----



=== Profile startup

.Time bound profiling at JVM startup (https://github.com/openjdk/jmc/blob/a07f3a28e65993909f6281ca5617f0ecc2b152a9/application/org.openjdk.jmc.ide.launch/src/main/java/org/openjdk/jmc/ide/launch/model/JfrArgsBuilder.java#L65[source])
[source]
----
-XX:StartFlightRecording=settings=profile,delay=20s,duration=60s,name=app-startup,filename=/app-startup.jfr
----

.In the container, checking JFR
[source]
----
❯ env --unset JAVA_TOOL_OPTIONS jcmd $(pgrep java) JFR.check
6:
Recording 1: name=app-startup duration=60s (running) <1>
❯ env --unset JAVA_TOOL_OPTIONS jcmd $(pgrep java) JFR.check
6:
No available recordings.

Use jcmd 6 JFR.start to start a recording. <2>
❯ ls -lah
-rw-r--r--   1 root root 3.3M May  6 22:35 rec.jfr
----
<1> Indicates the configured 30s recording is ongoing.
<2> No more recording once the duration is over.

=== Profile post-startup

.Delayed and time bound profiling at JVM startup (https://github.com/openjdk/jmc/blob/a07f3a28e65993909f6281ca5617f0ecc2b152a9/application/org.openjdk.jmc.ide.launch/src/main/java/org/openjdk/jmc/ide/launch/model/JfrArgsBuilder.java#L65[source])
[source]
----
-XX:StartFlightRecording=settings=profile,delay=20s,duration=60s,name=post-startup,filename=/post-startup.jfr
----

.In the container, checking JFR
[source]
----
❯ env --unset JAVA_TOOL_OPTIONS jcmd $(pgrep java) JFR.check
6:
Recording 1: name=post-startup duration=60s (delayed) <1>
❯ env --unset JAVA_TOOL_OPTIONS jcmd $(pgrep java) JFR.check
6:
Recording 1: name=app-startup duration=60s (running) <2>
❯ env --unset JAVA_TOOL_OPTIONS jcmd $(pgrep java) JFR.check
6:
No available recordings.

Use jcmd 6 JFR.start to start a recording. <3>
❯ ls -lah
-rw-r--r--   1 root root 3.3M May  6 22:35 rec.jfr
----
<1> Indicates there's a recording that will start at some point in the future.
<2> Indicates the configured 30s recording is ongoing.
<3> No more recording once the duration is over.


=== Continuous profiling


Started recording 1. No limit specified, using maxsize=250MB as default.


.Delayed and time bound profiling at JVM startup (https://github.com/openjdk/jmc/blob/a07f3a28e65993909f6281ca5617f0ecc2b152a9/application/org.openjdk.jmc.ide.launch/src/main/java/org/openjdk/jmc/ide/launch/model/JfrArgsBuilder.java#L65[source])
[source]
----
-XX:StartFlightRecording=settings=profile,delay=20s,maxage=30s,name=post-startup,filename=post-startup.jfr
----

This would create a rolling buffer of 30 seconds duration. There is no stipulation on how big this file could get,
unless the maxsize option is set the default is `maxsize=250MB`.

.In the container, checking JFR
[source]
----
❯ env --unset JAVA_TOOL_OPTIONS jcmd $(pgrep java) JFR.check
6:
Recording 1: name=post-startup duration=60s (delayed) <1>
❯ env --unset JAVA_TOOL_OPTIONS jcmd $(pgrep java) JFR.check
6:
Recording 1: name=app-startup duration=60s (running) <2>
❯ env --unset JAVA_TOOL_OPTIONS jcmd $(pgrep java) JFR.check
6:
No available recordings.

Use jcmd 6 JFR.start to start a recording. <3>
❯ ls -lah
-rw-r--r--   1 root root 3.3M May  6 22:35 rec.jfr
----
<1> Indicates there's a recording that will start at some point in the future.
<2> Indicates the configured 30s recording is ongoing.
<3> No more recording once the duration is over.

=== Profiling the startup then profile continuously

.Start to recording
[source]
----
-XX:StartFlightRecording=duration=30s,settings=profile,name=app-startup,filename=app-startup.jfr \
-XX:StartFlightRecording=delay=31s,maxsize=100mb,settings=profile,name=continuous,filename=continuous.jfr
----




=== Notes from JMC

// TODO help page from jdk mission control (JMC) ?

> Could not find a usable recording running in the JVM! You can get an automatically started
> continuous flight recording by using the JVM option `-XX:FlightRecorderOptions=defaultrecording=true`
> (also requires the options `-XX:+UnlockCommercialFeatures` `-XX:+FlightRecorder`).

// TODO commercial options not anymore

.JMC Help - § Managing Flight Recording Templates
====
1. Right-click a JVM in the JVM Browser and select Start Flight Recording
2. Click Template Manager in the Start Flight Recording Wizard.
JFR includes two pre-configured server-side recording templates:

** Continuous: A pre-configured template for continuous use in production environments with less than one percent overhead. This template is used for the default recording
** Profiling: A pre-configured template for profiling with around two percent overhead.
====

menu:JVM Browser>[Select a JVM>Start Flight Recording]

And from the _Start Flight Recording_ window, you can select configurations.

menu:Start Flight Recording[Event Settings]

At this time two configurations by default should appear.

* "Continuous _on server_"
* "Profiling _on server_"

I'm not sure yet but I believe the _on server_ mention means those are taken from the JVM shipped configurations
mentioned above, plus the description and label are similar.

* _Continuous_ refer to the `$JAVA_HOME/lib/jfr/default.jfc` (~1% overhead)
* _Profiling_ refer to the `$JAVA_HOME/lib/jfr/profile.jfc` (~2% overhead)

And anyway if these do not match your need it's possible to use your own configuration (`.jfc` files)
and manage them with the "_template manager_"

menu:Window[Flight Recoding Template Manager]



https://github.com/openjdk/jmc/blob/a07f3a28e65993909f6281ca5617f0ecc2b152a9/application/org.openjdk.jmc.ide.launch/src/main/java/org/openjdk/jmc/ide/launch/model/JfrArgsBuilder.java


== Memory Leak

Old Object Sample Event added in JDK 10 to profile memory leak, http://hirt.se/blog/?p=1055[blog from Marcus Hirt]

[source]
----
-XX:StartFlightRecording=settings=profile,path-to-gc-roots=true,...
----

.Difference in stacktrace setting
[source]
----
❯ cat ~/.asdf/installs/java/amazon-corretto-11.0.7.10.1/lib/jfr/profile.jfc | grep -A5 OldObjectSample
    <event name="jdk.OldObjectSample">
      <setting name="enabled" control="memory-leak-detection-enabled">true</setting>
      <setting name="stackTrace" control="memory-leak-detection-stack-trace">true</setting>
      <setting name="cutoff" control="memory-leak-detection-cutoff">0 ns</setting>
    </event>

❯ cat ~/.asdf/installs/java/amazon-corretto-11.0.7.10.1/lib/jfr/default.jfc | grep -A5 OldObjectSample
    <event name="jdk.OldObjectSample">
      <setting name="enabled" control="memory-leak-detection-enabled">true</setting>
      <setting name="stackTrace" control="memory-leak-detection-stack-trace">false</setting>
      <setting name="cutoff" control="memory-leak-detection-cutoff">0 ns</setting>
    </event>

----



=== Dump on exit

1. VM Crash => `hs_err<pid>.jfr`
2. OOM => `hs_oom<pid>.jfr`

add these options `dumponexit=true`, and override the filename if the above arent suited `dumponexitpath=/vm-exit.jfr`

.jfrOptionSet.cpp
[source]
----
static const ObsoleteOption OBSOLETE_OPTIONS[] = {
  {"checkpointbuffersize", ""},
  {"maxsize",              "Use -XX:StartFlightRecording=maxsize=... instead."},
  {"maxage",               "Use -XX:StartFlightRecording=maxage=... instead."},
  {"settings",             "Use -XX:StartFlightRecording=settings=... instead."},
  {"defaultrecording",     "Use -XX:StartFlightRecording=disk=false to create an in-memory recording."},
  {"disk",                 "Use -XX:StartFlightRecording=disk=... instead."},
  {"dumponexit",           "Use -XX:StartFlightRecording=dumponexit=... instead."},
  {"dumponexitpath",       "Use -XX:StartFlightRecording=filename=... instead."},
  {"loglevel",             "Use -Xlog:jfr=... instead."}
};
----


[source]
----
-Xlog:jfr
----



env --unset JAVA_TOOL_OPTIONS jcmd $(pidof java) JFR.start name=app-profile path-to-gc-roots=true maxsize=200mb settings=profile name=continuous-profile stackdepth=128 disk=true dumponexit=true filename=/gclogs/app-profile-$(date +%FT%H-%M-%S).jfr
env --unset JAVA_TOOL_OPTIONS jcmd $(pidof java) JFR.dump filename=/gclogs/hotspot-pid-6-2020_05_28_11_13_52.jfr



[source]
----
$ env --unset JAVA_TOOL_OPTIONS jcmd $(pidof java) VM.native_memory
6:

Native Memory Tracking:

Total: reserved=5324939KB, committed=3600539KB
-                 Java Heap (reserved=2793472KB, committed=2793472KB)
                            (mmap: reserved=2793472KB, committed=2793472KB)

-                     Class (reserved=1202747KB, committed=174583KB)
                            (classes #30836)
                            (  instance classes #28978, array classes #1858)
                            (malloc=6715KB #103633)
                            (mmap: reserved=1196032KB, committed=167868KB)
                            (  Metadata:   )
                            (    reserved=147456KB, committed=145988KB)
                            (    used=141426KB)
                            (    free=4562KB)
                            (    waste=0KB =0.00%)
                            (  Class space:)
                            (    reserved=1048576KB, committed=21880KB)
                            (    used=19330KB)
                            (    free=2550KB)
                            (    waste=0KB =0.00%)

-                    Thread (reserved=636185KB, committed=93205KB)
                            (thread #616)
                            (stack: reserved=633176KB, committed=90196KB)
                            (malloc=2222KB #3697)
                            (arena=787KB #1231)

-                      Code (reserved=255120KB, committed=101864KB)
                            (malloc=7432KB #29664)
                            (mmap: reserved=247688KB, committed=94432KB)

-                        GC (reserved=166886KB, committed=166886KB)
                            (malloc=29750KB #67554)
                            (mmap: reserved=137136KB, committed=137136KB)

-                  Compiler (reserved=4913KB, committed=4913KB)
                            (malloc=4847KB #2888)
                            (arena=66KB #5)

-                  Internal (reserved=9799KB, committed=9799KB)
                            (malloc=9799KB #16775)

-                     Other (reserved=135800KB, committed=135800KB)
                            (malloc=135800KB #552)

-                    Symbol (reserved=30719KB, committed=30719KB)
                            (malloc=25916KB #330226)
                            (arena=4803KB #1)

-    Native Memory Tracking (reserved=10409KB, committed=10409KB)
                            (malloc=108KB #1385)
                            (tracking overhead=10300KB)

-               Arena Chunk (reserved=217KB, committed=217KB)
                            (malloc=217KB)

-                   Tracing (reserved=75866KB, committed=75866KB)
                            (malloc=75866KB #85438)

-                   Logging (reserved=7KB, committed=7KB)
                            (malloc=7KB #269)

-                 Arguments (reserved=18KB, committed=18KB)
                            (malloc=18KB #507)

-                    Module (reserved=1856KB, committed=1856KB)
                            (malloc=1856KB #7920)

-              Synchronizer (reserved=885KB, committed=885KB)
                            (malloc=885KB #7308)

-                 Safepoint (reserved=8KB, committed=8KB)
                            (mmap: reserved=8KB, committed=8KB)

-                   Unknown (reserved=32KB, committed=32KB)
                            (mmap: reserved=32KB, committed=32KB)

----



== Real case startup request latencies

image:/assets/jfr/startup-0-thread-lanes.png[align="center"]
image:/assets/jfr/startup-0-threads-lanes-closer.png[align="center"]
image:/assets/jfr/startup-1-threads-jedis-lock-event.png[align="center"]
image:/assets/jfr/startup-1-threads-jedis-monitor-acquire-blocked.png[align="center"]
image:/assets/jfr/startup-1-threads-jedis-monitor-blocked-stack.png[align="center"]

image:/assets/jfr/startup-2-stack-01.png[align="center"]
image:/assets/jfr/startup-2-stack-02.png[align="center"]
image:/assets/jfr/startup-2-stack-03.png[align="center"]
image:/assets/jfr/startup-2-stack-04.png[align="center"]
image:/assets/jfr/startup-2-stack-05.png[align="center"]
image:/assets/jfr/startup-2-stack-06.png[align="center"]
image:/assets/jfr/startup-2-stack-07.png[align="center"]
image:/assets/jfr/startup-2-stack-08.png[align="center"]
image:/assets/jfr/startup-2-stack-09.png[align="center"]
image:/assets/jfr/startup-2-stack-10.png[align="center"]
image:/assets/jfr/startup-2-stack-11.png[align="center"]

image:/assets/jfr/startup-2-thread-lanes.png[align="center"]
image:/assets/jfr/startup-3-C2-compiler.png[align="center"]
image:/assets/jfr/startup-3-grafana.png[align="center"]
image:/assets/jfr/startup-4-threads-revoke-biased-locks.png[align="center"]
image:/assets/jfr/startup-5-before-after.png[align="center"]
image:/assets/jfr/startup-9-gc-pause-1.png[align="center"]
image:/assets/jfr/startup-9-gc-pause-2.png[align="center"]
image:/assets/jfr/startup-9-thread-lanes-gc-pauses-effect.png[align="center"]


== Controlling JFR programmatically

While JDK 14 allows to consume events on the fly, previous JDK versions (from JDK 11)
offer a public API to control Flight Recorder programmatically.

[source, java]
----
Configuration c = Configuration.getConfiguration("profile");
Recording r = new Recording(c);
r.setName("contunuous jaxrs");
r.enable(JaxRsIncovation.class);
r.setMaxAge(Duration.of(...));
r.start();
...
r.stop();
r.dump(Files.createTempFile("my-jaxrs", ".jfr"));
----
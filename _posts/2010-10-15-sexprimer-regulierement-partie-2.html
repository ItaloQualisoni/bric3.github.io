---
layout: post
title: S’exprimer régulièrement (Partie 2)
date: 2010-10-15 14:40:15.000000000 +02:00
type: post
published: true
status: publish
categories:
- code
- design
- pattern
- performance
tags: []
meta:
  _syntaxhighlighter_encoded: '1'
  _edit_last: '1'
  _su_rich_snippet_type: none
  suf_pseudo_template: default
author:
  login: brice
  email: brice.dutheil@gmail.com
  display_name: Brice Dutheil
  first_name: Brice
  last_name: Dutheil
---
<p>La première partie de cette mini-série s'est focalisée sur une petite intro, je n'ai pas vraiment insisté sur les bases des expressions régulières, j'ai juste abordé les ancres et les options, et j'ai parlé de certaines astuces à connaître. La suite de cette série continue comme prévu sur les constructions suivantes :</p>
<ul>
<li>Les groupes qui ne capturent pas (<em>non-capturing group</em>)</li>
<li>Les backreferences</li>
<li>Les autres quantificateurs
<ul>
<li>Les quantificateurs gourmands (dits <em>greedy quantifiers</em>)</li>
<li>Les quantificateurs paresseux (dits <em>lazy quantifiers</em> ou comme le dit la javadoc de Pattern <em>reluctant quantifiers</em>)</li>
<li>Les quantificateurs possessifs (dits <em>possessive quantifiers</em>)</li>
</ul>
</li>
<li>Le backtracking</li>
</ul>
<p>Certaines des constructions présentées ici démontrent que le moteur de regex de java fait partie des toutes dernières générations. Afin de mieux expliquer la manière de fonctionner des quantificateurs, je vais faire un tour sur la technique de backtracling du moteur de regex, feature essentiel pour faire fonctionner ces constructions.</p>
<p>Et aussi pourquoi certaines expressions régulières sont risquées en ce qui concerne les performances.</p>
<h1>Les groupes qui ne capturent pas</h1>
<h2>Pour comparer voici les groupes capturant</h2>
<p>Vous connaissez certainement déjà les groupes, par exemple :</p>
<pre class="lang:java decode:true">public class Groups {
  private static final String mail = "brice [dot] dutheil [at] gmail [dot] com";

  @Test
  public void grouping() {
    Matcher matcher = Pattern.compile("([a-z]+) ( ?\[[a-z]+\] ([a-z]+))+").matcher(mail);
    matcher.find();

    assertEquals("brice", matcher.group(1));
  }
}</pre>
<p>Dans l'expression ci-dessus, il y a trois groupes définis dans l'expression rationnelle.</p>
<ul>
<li>`<span style="color: black; background-color: rgba(0, 20, 255, 0.37);">(</span><span style="background-color: rgba(0, 20, 255, 0.1);">[a-z]+</span><span style="color: black; background-color: rgba(0, 20, 255, 0.37);">)</span> ( ?\[[a-z]+\] ([a-z]+))+` qui est donc le groupe 1</li>
<li>`([a-z]+) <span style="color: black; background-color: rgba(0, 20, 255, 0.37);">(</span><span style="background-color: rgba(0, 20, 255, 0.1);"> ?\[[a-z]+\] ([a-z]+)</span><span style="color: black; background-color: rgba(0, 20, 255, 0.37);">)</span>+` qui est le <strong>groupe 2</strong></li>
<li>`([a-z]+) ( ?\[[a-z]+\] <span style="color: black; background-color: rgba(0, 20, 255, 0.37);">(</span><span style="background-color: rgba(0, 20, 255, 0.1);">[a-z]+</span><span style="color: black; background-color: rgba(0, 20, 255, 0.37);">)</span>)+` enfin qui est le <strong>groupe 3</strong> il est défini à l'intérieur du groupe 2</li>
</ul>
<p>Le moteur de l'expression régulière enregistre juste la référence du groupe, et lorsque qu'il y a récursion sur les groupes, le groupe prend la valeur du dernier contenu matché. Ainsi dans cet exemple après un premier appel à <strong>find</strong>, l'ensemble de la chaîne de caractère a été consommée, et les groupes 2 et 3 son valorisés par :</p>
<pre class="lang:java decode:true">assertEquals("[dot] com", matcher.group(2));
assertEquals("com", matcher.group(3));</pre>
<p>En plus de ça, les références aux groupes sont limitées à 10. Honnêtement c'est rare d'avoir besoin de plus de 10 groupes. Dans ce cas il faut splitter la chaîne ou la regex.</p>
<p>Cependant on peut en partie s'arranger pour que les groupes qui ne nous intéressent pas ne soit pas référencés, il faut utiliser un groupe on-capturant.</p>
<h2>Les non-capturing groups</h2>
<p>C'est presque à la fin de la javadoc de la classe Pattern. Ils se construisent de la manière suivante :</p>
<pre class="lang:java decode:true">(?:regex)</pre>
<p>Pour reprendre l'exemple plus haut, le groupe 2 n'est pas vraiment utile à notre expression régulière. Du coup on pourrait écrire :</p>
<pre class="lang:java mark:7 decode:true">@Test
public void groupingNonCapturing() {
  Matcher matcher = Pattern.compile("([a-z]+) (?:[ ]?\[[a-z]+\] ([a-z]+))+").matcher(mail);
  matcher.find();

  assertEquals("brice", matcher.group(1));
  assertEquals("com", matcher.group(2));
}</pre>
<p>Il y a alors 2 groupes uniquement qui sont référencés.</p>
<p>Les constructions avancées des groupes sont la preuve que le moteur fait partie des dernière générations.</p>
<h1>Les backreferences</h1>
<p>Les références des groupes qui capturent, elles sont utilisées dans les moteurs de recherche et de remplacement. Typiquement avec Eclipse, le format utilisé pour faire référence à un groupe est :</p>
<pre>X</pre>
<p>Ou X est le numéro du groupe, sa référence.</p>
<p>En fait cette notation peut également s'utiliser à l'intérieur d'une expression régulière, c'est ce qu'on appelle donc une <strong>backrefrence</strong>. Pour back; parceque le groupe doit déjà être défini et matché pour être référencé dans une regex. Par exemple le cas le plus simple :</p>
<pre class="lang:java decode:true">assertTrue(Pattern.compile("([0-9]+) \1").matcher("123 123").matches());
assertFalse(Pattern.compile("([0-9]+) \1").matcher("123 1234").matches());</pre>
<p>Première assertion; le groupe 1 matche 123, la backreference va chercher à matcher le contenu exacte qui a été matché par le groupe 1, donc 123. La deuxième assertion montre bien que la backreference ne matchera pas 1234, car elle s'attend donc au même contenu que 123 (notez quand même l'utilisation de l'appel `matches()` plutôt que `find()`).</p>
<p>Bien entendu il faut que ce soit un groupe capturant, sinon la backreference ne sait pas ou chercher sa valeur. L'exemple qui suit montre un Pattern qui compile, mais qui ne fonctionnera pas:</p>
<pre class="lang:java decode:true">assertFalse(Pattern.compile("(?:[0-9]+) \1").matcher("123 123").matches());</pre>
<p>Le simple fait que ce pattern compile m'étonne, j'aurais plutôt choisi une approche <em>fail-fast</em> dans ce cas, c'est peut-être un oubli.</p>
<p>Ce genre de construction est assez pratique si on veut valider un langage comme le XML.</p>
<pre class="lang:java decode:true">assertTrue(Pattern.compile("&lt;([a-z]+)&gt;.*&lt;/\1&gt;").matcher("&lt;strong&gt;dude!&lt;/strong&gt;").matches());
assertTrue(Pattern.compile("&lt;([a-z]+)[^&gt;]*&gt;.*&lt;/\1&gt;").matcher("&lt;strong style=\"\"&gt;dude!&lt;/strong&gt;").matches());
assertTrue(Pattern.compile("&lt;([a-z]+)[^&gt;]*&gt;.*&lt;/\1&gt;").matcher("&lt;strong&gt;dude!&lt;/strong&gt;").matches());</pre>
<p>Attention il peut y avoir des astuces, en particulier sur le groupe qui fait le premier match. Par exemple dans le suivant on va voir le moteur regex valider l'expression, alors que la chaîne à valider n'est pas correcte :</p>
<pre class="lang:java decode:true">assertTrue(Pattern.compile("&lt;([a-z]+)[^&gt;]*&gt;.*!&lt;/\1&gt;").matcher("&lt;strong&gt;dude!&lt;/s&gt;").matches());</pre>
<p>Effectivement `&lt;strong&gt;&lt;/s&gt;` n'est pas correct syntaxiquement pour du XML pourtant, le moteur valide la séquence de caractère. En fait c'est un des features du moteur de regex, le <em>backtracking</em>, que je vais expliquer dans la section suivante. L'idée c'est que le moteur matche bien `strong` pour le <em>groupe 1</em>, mais lorsqu'il essaye de matcher la backreference avec `strong`, il n'y arrive pas donc il reviens en arrière jusqu'à ce que le <em>groupe 1</em> est pour valeur `s`, ce qui permet à la backreference de matcher. Le reste de la balise `trong` est matchée par cette partie de l'expression `[^&gt;]*`.</p>
<p>La solution, est d'utiliser une borne de mot vu dans la partie 1 de cette petite série d'article.</p>
<pre class="lang:default decode:true">assertFalse(Pattern.compile("&lt;([a-z]+\b)[^&gt;]*&gt;.*!&lt;/\1&gt;").matcher("&lt;strong&gt;dude!&lt;/s&gt;").matches());</pre>
<p>De cette façon le <em>groupe 1</em> `([a-z]+\b)` est littéralement obligé d'être suivi par autre chose qu'un caractère de mot (class `\w`). Avec cette expression la mauvaise séquence de caractère XML n'est donc plus validée.</p>
<p>Utilisation sympa des backreferences est de chercher dans un texte les mots répétés :</p>
<pre class="lang:java decode:true">assertTrue(Pattern.compile("\b(\w+)\s+\1\b").matcher("the the is repeated").find());</pre>
<h1>Les quantificateurs</h1>
<p>Les quantificateurs permettent comme leur nom l'indique de quantifier (une expression). À l'exception de l'opérateur de Kleene, géré par les moteurs de regex depuis très longtemps, tous les autres quantificateurs sont des représentations simplifiées de ce qui est exprimable par des constructions basiques.</p>
<ul>
<li style="text-align: justify;">`dady?` Le quantificateur optionnel peut s'exprimer par une alternative (attention à l'ordre) : `dady|dad`</li>
<li style="text-align: justify;">`(?:pa){1,3}` Le quantificateur borné peut s'exprimer en répétant les termes et/ou avec une alternative : `pa|papa|papapa`</li>
<li style="text-align: justify;">`vrou+m` Le quantificateur 1 ou plus peut être remplacé par l’occurrence 1 puis par une construction avec l'opérateur de Kleene : `vrouu*m`</li>
</ul>
<p>Bref ces notations simplifiées sont bien pratiques.</p>
<h2>Les quantificateurs gourmands (greedy quantifiers)</h2>
<p>Pas de surprise ces quantificateurs font partie de la catégorie des quantificateurs dit gourmands. Vous savez certainement déjà les utiliser, cependant il peut y avoir des cas qui peuvent poser problèmes.</p>
<p>Dans l'exemple suivant je voudrais chopper la balise ouvrante.</p>
<pre class="lang:default decode:true">public class Quantifiers {
  @Test
  public void greedy() {
    assertEquals("&lt;h1&gt;wont match&lt;/h1&gt;", regexFirstMatch("&lt;h1&gt;wont match&lt;/h1&gt;", "&lt;.+&gt;")); // greediness busted
    assertEquals("&lt;h1&gt;", regexFirstMatch("&lt;h1&gt;wont match&lt;/h1&gt;", "&lt;.+?&gt;"));
    assertEquals("&lt;h1&gt;", regexFirstMatch("&lt;h1&gt;wont match&lt;/h1&gt;", "&lt;[^&gt;]+&gt;"));
  }

  private String regexFirstMatch(String text, String regex) {
    Matcher matcher = Pattern.compile(regex).matcher(text);

    return matcher.find() ? matcher.group(0) : "didnt found match";
  }
}</pre>
<p>Dans la première approche on utilise un quantificateur gourmand `&lt;.+&gt;` ce qui veut dire que le moteur va essayer de consommer au maximum la séquence de caractères.</p>
<ol>
<li>Pour la section `.+` de la regex, le quantificateur va essayer de valider au maximum le `.`
<ul>
<li>Du coup le premier caractère `&gt;` est validé par la construction `.`,</li>
<li>Puis le deuxième (le dernier caractère) `&gt;` est également validé par `.`.</li>
</ul>
</li>
<li>Après ce dernier `&gt;` dans la séquence de caractère la chaîne complète est consommée, mais il reste le dernier `&gt;` <strong>dans l'expression rationnelle</strong>.</li>
<li>Du coup le moteur utilise le mécanisme de backtracking pour revenir en arrière, il tombe alors sur le `1` de `&lt;/h1&gt;`.</li>
<li>Finalement le `&gt;` de l'expression matche le `&gt;` de la séquence de caractère.</li>
</ol>
<p>Comme ce n'est pas ce qu'on veut récupérer, la balise ouvrante, une solution serait donc de prendre un <strong>quantificateur paresseux</strong> identifiable par le point d’interrogation qui suit le quantificateur.</p>
<p>Question performance dans le cas présent, il est plus intéressant de ne pas utiliser le point `.` avec un quantificateur paresseux mais plutôt d'utiliser un complément de l'ensemble qu'on ne veut pas matcher, c'est à dire une classe de caractère avec exclusion du caractère non voulu `&gt;`. C'est la troisième solution du bout de code (ligne 6).</p>
<h2>Les quantificateurs paressseux (lazy quantifiers)</h2>
<p>Ces quantificateurs sont bien nommés parce dans le genre, ils vont en faire vraiment le moins possible. Pour les comparer donc avec un quantificateur gourmand ou la séquence maximum est consommée (notez que la méthode <strong>regexFirstMatch</strong> est la même que dans le bout de code ci-dessus) :</p>
<pre class="lang:java decode:true">assertEquals("abc1abc2", regexFirstMatch("abc1abc2", "abc1(?:abc\d)?"));</pre>
<p>Le quantificateur `?` essaye de matcher la regex du groupe, et il y arrive, donc la séquence complète est consommée. Par contre ci la regex utilise une construction avec un quantificateur paresseux `??` :</p>
<pre class="lang:java decode:true">assertEquals("abc1", regexFirstMatch("abc1abc2", "abc1(?:abc\d)??"));</pre>
<p>Alors le quantificateur ne va pas s'emmerder à matcher, si la regex matche déjà ce qui est fait par la première partie de la regex `abc1`. Ce qu'il faut retenir c'est qu'un lazy quantifier, ne matchera jamais si le moteur valide déjà l'expression, et le corollaire est que le lazy quantifer cherchera toujours à matcher si et uniquement si la regex n'a pas déjà été validée.</p>
<p>Autre exemple avec un quantificateur borné :</p>
<pre class="lang:java mark:2 decode:true">assertEquals("abc1abc2abc3", regexFirstMatch("abc1abc2abc3", "(?:abc\d){2,3}")); // greediness busted
assertEquals("abc1abc2", regexFirstMatch("abc1abc2abc3", "(?:abc\d){2,3}?")); // lazyness
assertEquals("didnt found match", regexFirstMatch("abc1", "(?:abc\d){2,3}?"));</pre>
<p>À la ligne 2, le quantificateur paresseux est obligé d'être exécuté une fois au moins pour matcher, mais il en fait le moins possible.</p>
<h2>Les quantificateurs possessifs (possessive quantifiers)</h2>
<p>Les quantificateurs gourmands et paresseux, utilisent intelligement la capacité de backtracking afin d'évaluer les permutations possible qui permettent de valider l'expression régulière suivant leur stratégies respectives (<em>en faire le plus</em> ou <em>en faire le moins</em>). Cette propriété permet d'avoir des expressions assez souples pour matcher un grand nombre de séquence de caractère.</p>
<p>Cependant <strong>cette souplesse a un coût, le backtracking a un coût en mémoire et en temps CPU</strong>. Ce coût monte suivant la complexité de l'expression rationnelle et en fonction de la séquence de caractère. Pour des raisons de performance les créateurs des moteurs de regex ont introduit une nouvelle construction qui améliore les performances de votre regex : les quantificateurs possessifs.</p>
<p>Cette catégorie de quantificateur est un peu différente des deux autres, dans la mesure ou le <strong>backtracking est désactivé</strong>. Ce qui veut dire, si vous avez suivi, que l'expression régulière ne peut pas revenir en arrière chercher une précédente position ou la regex validait. Cependant il faut noter qu'un possessive quantifier cherche également à matcher le plus possible.</p>
<p>Typiquement dans le code suivant :</p>
<pre class="lang:java decode:true">assertEquals("&lt;h1&gt;will match&lt;/h1&gt;", regexFirstMatch("&lt;h1&gt;will match&lt;/h1&gt;&amp;amp;nbsp;", "&lt;.+&gt;"));</pre>
<p>La partie de l'expression régulière `.+` va tout matcher jusqu'au point virgule `;`. Seulement comme expliqué plus haut, une fois que la String est consommée, le caractère `&gt;` dans la regex ne peut pas matcher, donc le moteur reviens plusieurs fois sur ses pas, puis ressaye de matcher le `&gt;` de la regex. Ce comportement peut être désiré dans certains cas, mais parfois si on souhaite juste rechercher quelque chose de spécifique ou valider très vite un texte sans chercher d'autres combinaisons alors ce n'est pas l'idéal.</p>
<pre class="lang:java decode:true">assertEquals("didnt found match", regexFirstMatch("&lt;h1&gt;will match&lt;/h1&gt;&amp;amp;nbsp;", "&lt;.++&gt;"));</pre>
<p>Ici l'expression est constituée d'un possessive quantifier, et en effet l'expression ne matche pas parce qu’une fois que la regex a consommée l'ensemble de la chaîne, et qu'elle ne peut plus matcher le dernier `&gt;`, elle se déclare en erreur. On peut voir ça comme une construction du genre <em>fail-fast</em>.</p>
<p>L'intérêt véritable des constructions de cette catégorie est intéressante uniquement si les <strong>sections adjacentes de la regex sont mutuellement exclusives</strong>. L'exemple le plus prégnant est lorsqu'on utilise un complément avec un quantificateur possessif :</p>
<pre class="lang:default decode:true">assertFalse(Pattern.compile("&lt;[^&gt;]++&gt;").matcher("&lt;property attr1=\"blah\" ....&gt;&gt;").matches());</pre>
<p>Ici le complément `[^&gt;]` est naturellement mutuellement exclusif avec le caractère `&gt;`, ce qui permet à la regex d'invalider très vite la séquence de caractères (notez la fin de la chaîne `&gt;&gt;`). Si on avait utilisé un greedy quantifier, alors le moteur serait revenu en arrière autant de fois que possible pour tenter de valider l'expression, ce qui est impossible avec la séquence passée en paramètre.</p>
<p>Exemple à ne pas faire, car les tokens ne sont pas mutuellement exclusifs ; `a*+` immédiatement suivi d'un `a`, du coup la regex ne peut pas matcher car `a*+` consomme tous les `a` :</p>
<pre class="lang:java decode:true">assertFalse(Pattern.matches("\ba*+ab\b", "aaaaaaab"));</pre>
<p>Les quantificateurs possessifs sont des constructions qui sont supportées par les dernières générations de moteur de regex, parce qu'ils sont en réalité des groupes spéciaux. En effet dans la Javadoc de la classe <a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html">Pattern</a>, on trouve à la fin une partie sur les constructions spéciales, et celle qui nous intéresse dans ce cas, c'est celle là :</p>
<ul>
<li><strong>(?&gt;X)</strong> X, as an <strong>independent, non-capturing group</strong></li>
</ul>
<ol>
<li><em>"non capturing"</em> : Simplement parce que le groupe ne fait pas de capture lorsque X matche.</li>
<li><em>"independant"</em> : Ici ce n'est pas très clair dans la javadoc de Pattern, pour trouver la signification il faut se rendre sur la <a href="http://perldoc.perl.org/perlretut.html">documentation des regex en Perl</a>, on y apprend qu'il s'agit d'un groupe indépendant du reste de l'expression régulière, que ce groupe ne sait pas revenir en arrière (pas de backtracking), en gros le moteur de regex permet à ce groupe de consommer tout ce qu'il peut sans considérer les autres parties de la regex.</li>
</ol>
<p>Une petite vérification :</p>
<pre class="lang:default decode:true">assertTrue(Pattern.matches("\ba*+b\b", "aaaaaaab"));
assertFalse(Pattern.matches("\ba*+b\b", "aaaaaaa"));

assertTrue(Pattern.matches("\b(?&gt;a*)b\b", "aaaaaaab"));
assertFalse(Pattern.matches("\b(?&gt;a*)b\b", "aaaaaaa"));</pre>
<p>Donc un quantificateur possessif est une notation simplifiée d'un groupe indépendant et non capturant!</p>
<h1>Le backtracking</h1>
<p>Comme vous le savez, je l'ai bien répété, le backtracking c'est ce qui permet au moteur de regex de traquer les constructions qui ont validé. Le backtracking n'a de sens que pour les quantificateurs, en effet ce sont les quantificateurs qui vont essayer de tester une construction un certain nombre de fois. Cela dit cette construction peut-être suvi par une autre et le moteur doit s'assurer que les constructions qui suivent le quantificateur valident également le reste de la séquence.</p>
<p><span style="text-decoration: underline;">Prenons un exemple :</span></p>
<p>Dans le cas suivant on le pattern, observez le fait que le point `.` n'est pas mutuellement exclusif avec `bob`.</p>
<p>[plain]ab.*bob[/plain]</p>
<p>Et on essaye de valider la chaine de caractères, les chiffres sont là pour illustrer la partie sur la quelle la construction `.*` devrait matcher, mais des lettres auraient pu faire l'affaire.</p>
<p>[plain]ab1234bob[/plain]</p>
<p>A la première étape `Pattern.compile`, l'expression va être transformée dans un arbre. Techniquement le code ressemble à la fois au pattern <em>Chain of Responsability</em> et au pattern <em>Composite</em> (pour les groupes ou pour les quantificateurs notamment). Le moteur ajoute ses propres nœud au début et à la fin de l'arbre pour travailler avec cette représentation.</p>
<p>Dans le diagramme suivant chaque cadre correspond à l'état de la consommation de la séquence de caractère et à celui de l'expression régulière ainsi découpée en nœuds.</p>
<p style="text-align: center;"><a href="http://www.blog2.arkey.fr/wp-content/uploads/2010/10/backtracking.png"><img class="size-full wp-image-225 aligncenter" title="backtracking" src="{{ site.baseurl }}/assets/backtracking.png" alt="" width="397" height="1607" /></a></p>
<p>On comprend immédiatement le problèmes potentiels sur des expressions qui utilisent énormément les quantificateurs non-possessifs :</p>
<ul>
<li>Plus la partie à matchée est longue pour le quantificateur, plus la mémoire sera consommée.</li>
<li>Si les constructions qui suivent ne matchent pas, celles-ci devront être annulée et réessayée, ce qui veut dire un temps d’exécution plus long!</li>
</ul>
<p>La solution c'est de faire attention quand on construit une expression rationnelle. En particulier si elle est critique, l'idée serait de la benchmarquée, mais bon il faut pas tomber non plus dans ce qu'on appelle <strong>Premature Optimisation</strong>.</p>
<h1>Bilan</h1>
<p>Le backtracking c'est bien ; c'est ce qui permet à la regex d'être souple, mais clairement il faut faire attention à ce mécanisme. Il sera intéressant du coup d'utiliser des groupes non-capturants et indépendants si l'opportunité le permet.</p>
<p>Cette série s'achèvera par une troisième et dernière partie ou j'aborderaie les possibilité de travailler avec Unicode, et surtout comment indiquer dans une regex qu'on ne veut pas d'une construction complète.</p>
<p><em><br />
</em></p>
<h1>Références</h1>
<p><a href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html">http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html</a></p>
<p><a href="http://perldoc.perl.org/perlretut.html">http://perldoc.perl.org/perlretut.html</a></p>

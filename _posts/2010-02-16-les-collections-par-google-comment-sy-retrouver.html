---
layout: post
title: Les collections par Google, comment s'y retrouver?
date: 2010-02-16 15:51:49.000000000 +01:00
type: post
published: true
status: publish
tags:
- code
- google-collections
meta:
  _syntaxhighlighter_encoded: '1'
  _su_rich_snippet_type: none
  _edit_last: '1'
author:
  login: brice
  email: brice.dutheil@gmail.com
  display_name: Brice Dutheil
  first_name: Brice
  last_name: Dutheil
---
<p>Depuis quelques jours déjà le framework de collection par google est sorti en version 1.0. Ce framework a vu le jour chez Google donc, et s’impose finalement comme le prochain framework pour travailler avec les collections. En effet les classes utilitaires du JDK sont plutôt limitées et les classes commons-collections de Apache ne sont pas <em>générifiés</em>.</p>
<p>Les classes fournies par Google, ont été tunées pour être performante en rapidité et en utilisation mémoire. Si possible ce sont les collections standard du JDK, les collections du JDK sont mutables. Éventuellement l'utilisation des classes standard du JDK pourrait permettre à la JVM de faire les optimisation sur ces objets qu'il connait. Également aussi l'API orientée builder – un peu comme Joda-Time – facilite l'utilisation de google-collections.</p>
<p>Pour commencer, vous pouvez jeter un œil aux classes suivantes :</p>
<pre class="lang:java decode:true">com.google.common.collect.Collections2
com.google.common.collect.Lists
com.google.common.collect.Maps
com.google.common.collect.Sets
com.google.common.collect.ObjectArrays
com.google.common.collect.Multisets
com.google.common.collect.Multimaps
com.google.common.collect.Iterators
com.google.common.collect.Iterables</pre>
<p>Ces classes utilitaires permettent déjà d’instancier les collections avec quelques commodités, par exemple dans le code ci-dessous les classes retournées sont les <strong>classes mutables du JDK</strong> :</p>
<pre class="lang:java decode:true">LinkedHashSet&lt;String&gt; linkedHashSet = Sets.newLinkedHashSet();
ArrayList&lt;AGenericObject &lt;Class&lt;Observer&gt;&gt;&gt; arrayList = Lists.newArrayList();
Lists.newArrayList("bob", "marie", "barack", "bruce");</pre>
<p>à la place de :</p>
<pre class="lang:default decode:true">List&lt;AGenericObject&lt;Class&lt;Observer&gt;&gt;&gt; list = new ArrayList&lt;AGenericObject&lt;Class&lt;Observer&gt;&gt;&gt;();</pre>
<p>Voilà rapidement pour les utilitaires des collections fournies par le JDK, mais Google fournit également des <strong>implémentations immutables</strong> des collections :</p>
<pre class="lang:java decode:true">ImmutableSet&lt;integer&gt; immutableSet = ImmutableSet.of(1, 2, 3, 4, 5);
ImmutableList&lt;string&gt; immutableList = ImmutableList.of("a,b,c,d,e,f,g".split(","));</pre>
<p>Pour les maps, il y a aussi une API plutôt expressive et facilement utilisable. Par exemple pour créer facilement une multimap:</p>
<pre class="lang:java decode:true">Multimap&lt;color , Fruit&gt; colorIndex = HashMultimap.create();
for (Fruit fruit : fruits) {
    colorIndex.put(fruit.getColor(), fruit);
}
Collection&lt;Fruit&gt; redFruits = colorIndex.get(Color.RED);</pre>
<p>Si on veut jouer avec des map bi-directionnelles.</p>
<pre class="lang:java decode:true">ImmutableBiMap&lt;Integer , String&gt; biMap = ImmutableBiMap.of(0, "Zero", 1, "One", 2, "Two", 3, "Three");
biMap.inverse().get("Zero"); // =&gt; 0</pre>
<p>L’outil MapMaker pour créer des maps customisées :</p>
<pre class="lang:java decode:true">Map&lt;Params , Result&gt; resultCache = new MapMaker().expiration(5 * 60,TimeUnit.SECONDS)
    .makeComputingMap(new Function&lt;Params , Result&gt;() {
        public Result apply(Params param) {
            return computeHeavyAlgorythm();
        }
    }).makeMap();</pre>
<p>Il est aussi possible de ne pas utiliser l’expiration mais de choisir plutôt des WeakReference ou des SoftReference pour les clés et/ou les valeurs.</p>
<p>Comment utiliser les Multiset. A noter, le Multiset ci-dessous est mutable! Pur un MultiSet immutable il faut le créer avec ImmutableMultiset.</p>
<pre class="lang:java decode:true">Multiset&lt;String&gt; histogram = HashMultiset.create();
histogram.add("Hello");
histogram.add("World", 3);
histogram.add("Hello");
histogram.add("!");

int count;
count = histogram.count("Hello");    // 2
count = histogram.count("World");    // 3
count = histogram.count("Brice");    // 0</pre>
<p>Et pour les itérateurs :</p>
<pre class="lang:java decode:true">UnmodifiableIterator&lt;Object&gt; tokenizerIt = Iterators.forEnumeration(new StringTokenizer("a|b|c|d|e", "|")); // Eh oui ! StringTokenizer implémente Enumeration&lt;Object&gt;

UnmodifiableIterator&lt;String&gt; splitIt = Iterators.forArray("e|ed|f|g|h|i".split("|"));

Iterator&lt;object&gt; concatenatedIt = Iterators.concat(tokenizerIt, splitIt);

Iterators.frequency(concatenatedIt, "e"); // 2
concatenatedIt.hasNext(); // false</pre>
<p>Ok maintenant que nous avons vu comment créer des collections, on peut regarder comment vraiment jouer avec. Ordonner une collection par exemple; il faut utiliser la classe Ordering (étends l’interface Comparator de java)</p>
<pre class="lang:java decode:true">Function&lt;Fruit , Color&gt; getColorFunction = new Function() {
    public Color apply(Fruit from) {
        return from.getColor();
    }
};

Function&lt;Fruit , String&gt; getNameFunction = new Function() {
    public String apply(Fruit from) {
        return from.getName();
    }
};

Ordering&lt;Fruit&gt; colorOrdering = Ordering.natural().onResultOf(getColorFunction);
Ordering&lt;Fruit&gt; nameOrdering = Ordering.natural().onResultOf(getNameFunction);

// ordonner par couleur puis par nom
Ordering&lt;Fruit&gt; colorAndNameOrdering = colorOrdering.compound(nameOrdering);

List&lt;Fruit&gt; sortedFruitList = Ordering.natural().sortedCopy(fruits);
Set&lt;Fruit&gt; sortedFruits = ImmutableSortedSet.orderedBy(colorAndNameOrdering).addAll(fruits).build();</pre>
<p>Filtrer des éléments est devenu super facile à utiliser. Il nous faut les classes Predicate et Predicates.</p>
<pre class="lang:java decode:true">List&lt;String&gt; names = Lists.asList("Clément", "Jean-Max", "Caroline", "Céline", "Brice");
Iterable&lt;String&gt; filtered = Iterables.filter(
    names,
    Predicates.or(
        Predicates.or(Predicates.equalTo("Clément"), Predicates.equalTo("Brice")),
        returnALengthPredicate(5)
    )
);</pre>
<p>Il est possible de faire des transformations</p>
<pre class="lang:java decode:true">Lists.transform(lotoNumbers, new Function&lt;String , Integer&gt; {
    public Integer apply(final String from) {
        return Integer.valueOf(from);
    }
});</pre>
<p>Que peut-on faire d’autre? Par exemple avec les maps et les sets, on peut observer les différences, faire des unions, ou faire des intersections.</p>
<pre class="lang:java decode:true">MapDifference&lt;String , Integer&gt; differenceMap = Maps.difference(mapA, mapB);
differenceMap.areEqual();
Map&lt;String , ValueDifference&lt;Integer&gt;&gt; entriesDiffering = differenceMap.entriesDiffering();
Map&lt;String , Integer&gt; entriesOnlyOnLeft = differenceMap.entriesOnlyOnLeft();
Map&lt;String , Integer&gt; entriesOnlyOnRight = differenceMap.entriesOnlyOnRight();
Map&lt;String , Integer&gt; entriesInCommon = differenceMap.entriesInCommon();</pre>
<p>On peut également faire de l’indexation sur des listes de map :</p>
<pre class="lang:java decode:true">List&lt;String&gt; badGuys = Arrays.asList("Inky", "Scratchy", "Blinky", "Pinky", "Pinky", "Clyde");
Function&lt;String , Integer&gt; stringLengthFunction = ...;

Multimap&lt;String , Integer&gt; index = Multimaps.index(badGuys, stringLengthFunction); // { 4=[Inky], 5=[Pinky, Pinky, Clyde], 6=[Blinky], 7=[Scratchy] }</pre>
<p>Au cas ou pour éviter de chercher voici quelques méthodes utilitaires dans Iterables, d'ailleurs c'est là qu'on retrouve le fameux isEmpty. (Attention la librairie google ne vérifie pas la nullité, et leur argument est de ne pas encourager de retourner null mais plutôt des collections vide, bref ce que dit Joshua Blosh dans son fameux livre Effective Java, §Item 43)</p>
<pre class="lang:java decode:true">Iterables.getOnlyElement(ImmutableSet.of("1")); // 0
Iterables.getOnlyElement(ImmutableSet.of("1", "2")); // IllegalArgumentException

Iterables.isEmpty(ImmutableMultiset.of()); // true
Iterables.isEmpty(null); // NullPointerException
Iterable&lt;String&gt; moreFruits = Iterables.concat(ImmutableMultiset.of("apple", "banana", "kiwi"), Lists.newArrayList("ananas", "orange")); // "apple", "banana", "kiwi", "ananas", "orange"
String kiwi = Iterables.getLast(ImmutableMultiset.of("apple", "banana", "kiwi")); // "kiwi"

Iterable&lt;List &lt;String&gt;&gt; fruitBasket = Iterables.partition(moreFruits, 2);  // { "apple", "banana" }, { "kiwi", "ananas" }, { "orange" }</pre>
<p>Pour passer d’un Iterable à un tableau :</p>
<pre class="lang:java decode:true crayon-selected">Iterables.toArray(Lists.newArrayList(new DateTime(), new DateTime().plusDays(1)), DateTime.class);</pre>
<p>Voilà il y a pas mal de petits trucs bien sympa, ceci dit il peut manquer des choses qui nous semblent essentielles. Mais cette bibliothèque apporte enfin des choses qui nous simplifient la vie. Les commons-collection ont bien marqués nos habitudes, mais pour s’y retrouver et utiliser cette bibliothèque à bon escient il est certain qu'il va falloir faire un petit effort.</p>

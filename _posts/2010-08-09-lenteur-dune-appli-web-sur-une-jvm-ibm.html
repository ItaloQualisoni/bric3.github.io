---
layout: post
title: Lenteur d'une appli Web sur une JVM IBM
date: 2010-08-09 16:16:43.000000000 +02:00
type: post
published: true
status: publish
categories:
- code
- mco
- performance
- prod
tags:
- fuite
- memoryleak
- performance
meta:
  _syntaxhighlighter_encoded: '1'
  _msp_keywords: IBM, J9, IBM J9, WebSphere, JVM, Thread Dump, ps, Waiting On Condition,
    GC, Garbage Collector
  _wp_old_slug: lenteur-dune-appli-web-sur-une-jvm-ibm-partie-1
  _msp_description: ''
  _su_rich_snippet_type: none
  _edit_last: '1'
author:
  login: brice
  email: brice.dutheil@gmail.com
  display_name: Brice Dutheil
  first_name: Brice
  last_name: Dutheil
---
<p>Sujet intéressant, les problèmes en production sont quand même pour beaucoup des casse-têtes. Effectivement c'est bien vrai, les problèmes en production sont difficiles à résoudre. Il y a bien une partie technique souvent absconse, mais ce n'est pas un travail en solitaire, c'est un travail d'équipe. L'organisation dans la boite favorise ou freine cette opportunité de résoudre un problème à travers les différentes équipe impliquées. Dans ce billet je vous fait un petit retour d'expérience sur un problème de lenteur sur une application web genre "<em>CRUD</em>" sur une JVM IBM.</p>
<h1>Le contexte</h1>
<p><em>"The context is King"</em> disait Andy Hunt dans son livre Pragmatic Learning and Thinking. Alors brève introduction au contexte du problème.</p>
<ul>
<li>Application assez simple qui permet de rechercher, consulter, créer, modifier des données différentes issues du domaine métier.</li>
<li>L'application tourne sur un WebSphere.</li>
<li>WebSphere tourne sur une JVM IBM. <em>Ah là ça sent la pêche aux informations, n'ayant jamais travaillé sur cette JVM, et pas de bol non plus la JVM IBM sur Windows n'est pas accessible gratuitement depuis le site de IBM.</em></li>
<li>L'ensemble tourne sur une machine AIX.</li>
<li>L'entreprise utilise l'outils Introscope qui permet d'avoir plein de métriques.</li>
</ul>
<h1>Le problème</h1>
<p>Les utilisateurs ressentent des lenteurs, voire des freezes. L'outil INSC identifie ces threads en <em>Stalled</em>, et permet de donner des métriques sur les temps d'attentes et de réponses de certains éléments du systèmes, les ingénieurs systèmes utilisent abondamment cet outils. Bref, les temps de réponses vont de quelques dizaines de secondes à plusieurs minutes.</p>
<p>Il y a définitivement un problème. Forcément quand on a un super outils comme INSC qui a plein de métriques, on se balade dedans pour essayer de trouver le problème. Malheureusement <strong>un seul</strong> thread dump pour voir ce qu'il se passe dans les threads ne suffit pas. Le thread dump révèle que la plupart des threads sont à l'état "<strong>Waiting On Condition</strong>". Le super outils INSC indique un usage de la heap, il indique aussi que certaines requêtes SQL sont très très longues, il indique les sessions web ouvertes une petite trentaine, pas de quoi fouetter un chat. Et pourtant il y aurait du CPU assez fortement utilisé, vu depuis Introscope.</p>
<p>Mais voilà l'analyse tourne un peu autour du pot. Pourquoi ces threads sont-elles bloquées? Pourquoi les requêtes SQL sont-elles aussi longues?!</p>
<h1>Le problème dans l'analyse</h1>
<p>Récapitulons, dans cette situation les métriques de Introscope ont été regardées, et on a un seul thread dump.</p>
<p>Introscope malgré ces métriques ne dit pas ou est le problème, il ne dit même pas quel est le type de problème. Les métriques affichées sont pour certaines intéressantes, je pense à l'identification des threads figées, les temps de réponses de certains composants, la consommation mémoire, et l'utilisation du CPU.</p>
<p>Mais pourquoi cet outils n'a pas aidé à trouver le problème, parce qu'il ne mesure pas les bonnes choses. Et il faut en particulier comprendre que quand un système fonctionne mal il y a un effet de corrélation qui s'applique sur un ensemble de variable. Et ce n'est pas avec Introscope qu'on va pouvoir identifier la cause du ralentissement généralisé, ni trouver<strong> une relation de cause-à-effet</strong>.</p>
<blockquote><p>Pour résoudre un problème, il faut s'équiper avec les bons outils! Il faut aussi regarder les bonnes données, au bon endroit, et au bon moment!</p></blockquote>
<h1>A la poursuite du vrai problème (partie 1)</h1>
<p>Bon hop, déjà pour commencer j'écarte pour le moment Introscope. Et j'ai un thread dump ... de la JVM de IBM, il va falloir essayer les outils IBM qui permettent de traiter ces informations. Je vais me satisfaire ça pour l'instant.</p>
<h2>L'analyse du thread dump</h2>
<h3>Avec : IBM Thread and Monitor Dump Analyzer for Java</h3>
<p>Évidement le format ne correspond pas à celui de Sun, heureusement IBM nous fournit des outils pour analyser ces informations. Direction <a href="http://www.alphaworks.ibm.com/tech/jca">http://www.alphaworks.ibm.com/tech/jca</a>.</p>
<p>A l'ouverture un rapport apparait, il commence par ça en rouge :</p>
<blockquote><p><span style="color: #993300;">***WARNING*** Java heap is almost exhausted : 0% free Java heap Please enable verbosegc trace and use IBM Pattern Modeling and Analysis Tool(http://www.alphaworks.ibm.com/tech/pmat) to analyze garbage collection activities. If heapdumps are generated at the same time, please use IBM HeapAnalyzer(http://www.alphaworks.ibm.com/tech/heapanalyzer) to analyze Java heap.</span></p></blockquote>
<p>Ok, là c'est assez facile de savoir ou ça va! Mais allons plus loin!</p>
<p>Il y a également :</p>
<blockquote><p><strong>Number of Processors : </strong><strong>4</strong><br />
Java version : J2RE 5.0 <strong>IBM J9</strong> 2.3 AIX ppc64-64 build j9vmap6423-20090707</p>
<p>Java Heap Information<br />
<strong>Maximum Java heap size : 384m<br />
Initial Java heap size : 384m</strong></p></blockquote>
<p>OK, j'en apprends un peu plus sur la JVM et la machine.</p>
<blockquote><p>Free Java heap size: 0 bytes</p>
<p>Allocated Java heap size: 402 653 184 bytes</p></blockquote>
<p>Ok évidement tout s'explique il ne reste plus rien pour allouer dans la Heap.</p>
<p>Tiens dans la ligne de commande je voit que Introscope est un agent de le JVM:</p>
<blockquote>
<pre class="lang:default decode:true ">-Xshareclasses:name=webspherev61_%g,groupAccess,nonFatal
-Dibm.websphere.internalClassAccessMode=allow
-Dcom.wily.introscope.agentProfile=/opt/wily/wilyAgent/AvtAgent.profile
-javaagent:/opt/wily/wilyAgent/Agent.jar</pre>
</blockquote>
<p><strong>C'est intéressant, si la JVM est lente, ca peut vouloir dire que les mesures Introscope sont aussi soumises aux lenteurs de la JVM.</strong></p>
<p>Le rapport est sympa, il donne la répartition de la mémoire de la JVM :</p>
<blockquote><p>Memory Segment Analysis</p>
<table style="background-color: #000000; width: 557px; height: 193px; border: 1px solid #000000;" border="1" cellspacing="1" cellpadding="2">
<thead>
<tr>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">Memory Type</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right"># of Segments</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">Used Memory(bytes)</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">Used Memory(%)</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">Free Memory(bytes)</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">Free Memory(%)</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">Total Memory(bytes)</td>
</tr>
</thead>
<tbody>
<tr>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">Internal</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">13</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">1 191 740</td>
<td style="border: 0px solid #000000;" align="right"><span style="background-color: #ffff00;">88,4</span></td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">156 452</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">11,6</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">1 348 192</td>
</tr>
<tr>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">Object (reversed)</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">1</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">402 653 184</td>
<td style="border: 0px solid #000000;" align="right"><span style="background-color: #ffff00;">100</span></td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">0</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">0</td>
<td style="border: 0px solid #000000;" align="right"><span style="background-color: #ffff00;">402 653 184</span></td>
</tr>
<tr>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">Class</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">9 735</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">228 637 344</td>
<td style="border: 0px solid #000000;" align="right"><span style="background-color: #ffff00;">90,96</span></td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">22 724 116</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">9,04</td>
<td style="border: 0px solid #000000;" align="right"><span style="background-color: #ffff00;">251 361 460</span></td>
</tr>
<tr>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">JIT Code Cache</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">5</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">41 943 040</td>
<td style="border: 0px solid #000000;" align="right"><span style="background-color: #ffff00;">100</span></td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">0</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">0</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">41 943 040</td>
</tr>
<tr>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">JIT Data Cache</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">3</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">17 018 496</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">67,63</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">8 147 328</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">32,37</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">25 165 824</td>
</tr>
<tr>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">Overall</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">9 757</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">691 443 804</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">95,71</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">31 027 896</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">4,29</td>
<td style="border: 0px solid #000000; background-color: #ffffff;" align="right">722 471 700</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Ok, c'était un tableau intéressant, on voit clairement que dans une JVM il n'y a pas que de la Heap (pour ceux qui ne le savait pas), en effet on voit donc les sections suivantes (les passages surlignés viennent de moi, malheureusement l'outil d'IBM ne nous aide pas là dessus) :</p>
<ul>
<li>la mémoire interne de la JVM (les objets internes, les structure de thread, et autres objets natifs) : bonne utilisation</li>
<li>les objets, en une seule section de mémoire, c'est la Heap, et là ben effectivement elle utilisée à 100%.</li>
<li>les sections des classes, c'est la ou le byte code de vos classes est stocké par la JVM, <strong>mais ce n'est pas dans la Heap</strong> (chez la JVM de Sun ça correspondrait à la PermGen area), bref là aussi 90% d'utilisation c'est plutôt pas mal.</li>
<li>JIT Code Cache et JIT Data Cache, c'est là ou la JVM va stocker le code natif qu'elle aura compilée depuis le bytecode, là aussi c'est rempli à100% mais c'est peut-être normal, après tout la taille totale est plus petite.</li>
</ul>
<p>On voit aussi que la mémoire accessible dans la Heap est quand même supérieure a ce qui est indiqué dans la ligne de commande, à savoir les 384 MB. Ne connaissant pas la JVM IBM, je ne suis pas certains des raisons induisant ce phénomène.</p>
<p>Mais à 100% d'utilisation, ça sent le GC qui s'excite pour garder ses petits. Mais le rapport est long et n'est pas terminé, il reste des choses à lire.</p>
<blockquote><p>Thread Status Analysis</p>
<table style="background-color: #000000; border: 1px solid #000000;" border="1" cellspacing="1" cellpadding="2">
<tbody>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Status</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Number of Threads : 170</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Percentage</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Deadlock</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Runnable</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">12</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">7 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Waiting on Condition</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">158</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">93 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Waiting On Monitor</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Suspended</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Object.wait()</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Blocked</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Parked</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">0 %</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Vous vous souvenez des threads vues en <strong>Wait on Condition</strong> au tout début, on les retrouve donc ici dans les stats du thread dump. Il y a environ 158 thread qui ne font rien et 12 threads qui travaillent. Alors petite parenthèse, qu'est ce que ça veut dire ce Waiting on Condition. Les raisons peuvent être les suivantes :</p>
<ul>
<li>Thread.sleep(), en gros on indique simplement à la thread de ne rien faire, mais c'est quand même la JVM qui gère ce sleep()</li>
<li>Object.wait(), en gros quelque part dans le code un thread est en attente pour qu'une condition se réalise, voire le code en question pour en savoir plus sur la condition. Cette condition peut aussi être une condition interne à la JVM.</li>
<li>La thread est en train de se synchroniser avec une autre, elle doit donc attendre que l'autre thread finisse son job, on verra probablement dans la stack un appel à un Thread.join().</li>
<li>Unsafe.park, et autres support pour les lock</li>
<li>La thread est blockée par des opérations d'I/O.</li>
</ul>
<p>Déjà ce n'est pas forcément un problème pour toutes les threads, typiquement on peut s'attendre à voir des threads relatives aux systèmes de cache (ehcache et consorts) qui sont dans ces états. Ensuite il faut comprendre que ce mécanisme implique des conditions internes à la JVM. L'ordonnanceur (scheduler) de la JVM, qui en réalité fait appel au scheduler de l'OS, donne la main à d'autres traitements (java ou pas).</p>
<p>Le prochain tableau du rapport nous indique ou sont (toutes) nos threads, mais pas d'analyse par type de statut. On observe bien certaines des raisons citées plus haut.</p>
<blockquote><p>Thread Method Analysis</p>
<table style="background-color: #000000; border: 1px solid #000000;" border="1" cellspacing="1" cellpadding="2">
<tbody>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Method Name</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Number of Threads : 170</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">Percentage</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">java/lang/Object.wait(Native Method)</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">88</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">52 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">java/lang/Thread.sleep(Native Method)</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">63</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">37%</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">NO JAVA STACK</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">6</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">4 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">java/net/PlainSocketImpl.socketAccept(<strong>Native Method</strong>)</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">5</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">3 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">java/net/SocketInputStream.socketRead0(<strong>Native Method</strong>)</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">3</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">2 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">com/ibm/misc/SignalDispatcher.waitForSignal(<strong>Native Method</strong>)</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">1</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">1 %</td>
</tr>
<tr>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right">d'autres ligne à 1%...</td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right"></td>
<td style="border-width: 0px; border-style: solid; background-color: #ffffff;" align="right"></td>
</tr>
</tbody>
</table>
</blockquote>
<p>Pas mal de thread sont en attente, et beaucoup d'autres dorment. Quelques threads sans stack Java, ce sont des threads qui appartiennent à la JVM.</p>
<p>J'arrête là pour le moment  sur le rapport de cet outils IBM, mais ce qu'il faut retenir c'est que le thread dump est utile pour étudier des threads, mais c'est utile sur un laps de temps, avec un seul cliché on ne se rends pas compte réellement du comportement. Et en plus ces données ne sont pas intéressantes pour savoir ce qu'il se passe coté gestion mémoire. Heureusement que J9 (la JVM de Mr IBM) fournit quelques infos, sinon je ne vois pas comment diagnostiquer le problème sans jeter un œil sur les données adéquates, c'est à dire le log du Garbage Collector.</p>
<h2>L'analyse du log GC, enfin!</h2>
<p>Après l'obtention du fameux log, il faut encore trouver un outil IBM pour analyser le fichier. Les choses deviennent intéressantes. Comme je l'ai déjà dit, les logs sont au format IBM, ça ressemble à du XML. Et pour analyser ces logs rien de mieux que les outils de IBM, non? Google me dit rapidement qu'il me faut donc ce truc <strong>Pattern Modeling and Analysis Tool for Java Garbage Collector</strong>, direction <a href="http://www.alphaworks.ibm.com/tech/pmat">http://www.alphaworks.ibm.com/tech/pmat</a>.</p>
<h3>Avec : Pattern Modeling and Analysis Tool for Java Garbage Collector</h3>
<p>Un petit graphique pour regarder ce qu'il se passe.</p>
<p><a href="http://www.blog2.arkey.fr/wp-content/uploads/2010/07/gclog.png"><img class="alignnone size-full wp-image-148" title="gclog" src="{{ site.baseurl }}/assets/gclog.png" alt="" width="869" height="621" /></a></p>
<p>En rouge l'usage de la Heap, en bleu le marquage des objets à virer, et en vert les temps de compression de la mémoire. Effectivement le GC à l'air de bien s'amuser dans la mémoire, et d'être appelé assez souvent.</p>
<p>Bon celà dit je ne suis pas convaincu par l'outil IBM, il manque des informations que j'avais vu en texte dans le log GC ; un évènement GC à  cette tête là :</p>
<pre class="lang:xml mark:1,4,8,17,21 decode:true ">&lt;af type="tenured" id="388571" timestamp="Jun 21 03:01:11 2010" intervalms="228.858"&gt;
  &lt;minimum requested_bytes="168" /&gt;
  &lt;time exclusiveaccessms="0.489" /&gt;
  &lt;tenured freebytes="0" totalbytes="402653184" percent="0" &gt;
    &lt;soa freebytes="0" totalbytes="402653184" percent="0" /&gt;
    &lt;loa freebytes="0" totalbytes="0" percent="0" /&gt;
  &lt;/tenured&gt;
  &lt;gc type="global" id="388576" totalid="388576" intervalms="230.720"&gt;
    &lt;refs_cleared soft="0" threshold="32" weak="76" phantom="0" /&gt;
    &lt;finalization objectsqueued="0" /&gt;
    &lt;timesms mark="408.282" sweep="5.061" compact="0.000" total="415.341" /&gt;
    &lt;tenured freebytes="209018360" totalbytes="402653184" percent="51" &gt;
      &lt;soa freebytes="209018360" totalbytes="402653184" percent="51" /&gt;
      &lt;loa freebytes="0" totalbytes="0" percent="0" /&gt;
    &lt;/tenured&gt;
  &lt;/gc&gt;
  &lt;tenured freebytes="209013328" totalbytes="402653184" percent="51" &gt;
    &lt;soa freebytes="209013328" totalbytes="402653184" percent="51" /&gt;
    &lt;loa freebytes="0" totalbytes="0" percent="0" /&gt;
  &lt;/tenured&gt;
  &lt;time totalms="417.431" /&gt;
&lt;/af&gt;</pre>
<p>Vu l'allure du log, on a pas l'impression d'être sur un GC de type generationnel, mais je ne suis pas encore sûr, c'est une JVM IBM. Bon revenons à nos moutons:</p>
<ul>
<li>il y a eu 230 ms d'écoulées avant le dernier GC.</li>
<li>la tenured indique directement qu'il n'y a plus de place dans la mémoire,</li>
<li>on voit que le GC est de type global, ce qui veut dire que c'est toute la zone mémoire qui est affectée par le GC, c'est long</li>
<li>la tenured libère environ 200 MB, soit 51%!</li>
<li>le temps total mis par ce GC est de 420 ms, c'est long.</li>
</ul>
<p>Et il y a plein d'entrées comme ça, ça fait beaucoup de GC globaux de 1 demi-secondes, tous les 5ème de secondes. Le GC prends du temps CPU pour nettoyer la mémoire un peu trop souvent. Et ce ci pourrait bien être la cause des ralentissements observés. En gros soit il n'y a simplement pas assez de mémoire, soit il y a une fuite mémoire.</p>
<h3>Avec : IBM Support Assistant et Garbage Collection and Memory Visualizer</h3>
<p>En me renseignant, je voulais jeter un œil aux outils IBM plus récents, tel que celui mentionné par <a href="http://www.parisjug.org/xwiki/bin/view/Meeting/20100608">Holly Cummins au ParisJug</a> (le 8 Juin 2010). Pour commencer il faut un compte IBM et télécharger <strong>IBM Support Assistant</strong>, direction <a href="http://www-01.ibm.com/software/support/isa/">http://www-01.ibm.com/software/support/isa/</a>.</p>
<p>Après une fois qu'on a l'outil, il faut à nouveau télécharger des plugins (nommé <em>additif</em> sur l'interface en français). Bon en fait le Health Center en me sert à rien puisqu'il il faut se connecter à une <strong>JVM IBM</strong>, ayant une JVM Sun sur mon poste je ne vais quand même pas aller taper sur la prod si tenté que ce soit possible. Finalement j'opte pour le plugin : <strong>Garbage Collection and Memory Visualizer</strong>.</p>
<p>Donc finalement j'essaye cet outils d'analyse, et j'ai un rapport bien plus sympa et complet avec plein de graphiques qui m'intéressent.</p>
<p>Déjà le rapport débute par :</p>
<blockquote><p>Your application appears to be leaking memory. This is indicated by the used heap increasing at a greater rate than the application workload (measured by the amount of data freed). To investigate further see <a href="http://publib.boulder.ibm.com/infocenter/javasdk/tools/index.jsp?topic=/com.ibm.java.doc.igaa/_1vg00011e17d8ea-1163a087e6c-7ffe_1001.html">Guided debugging for Java</a></p></blockquote>
<p>Ok, je m'en doutais déjà mais c'est quand même mieux que de dire que la mémoire est quasiment entièrement utilisée. Et on retrouve les alertes suivantes dans le rapport :</p>
<blockquote><p>The application seems to be using some quite large objects. The largest request which triggered an allocation failure (and was recorded in the verbose gc log) was for 5242904 bytes.</p></blockquote>
<p>5MB quand même! Cela dit ça n'arrive pas souvent, c'est peut-être un cache qui charge des données depuis le disque. Le graphe suivant (choisir Object Size dans les templates de graphique sur la droite) montre la taille des allocations demandées.</p>
<p><a href="http://www.blog2.arkey.fr/wp-content/uploads/2010/07/object_sizes.jpg"><img class="alignnone size-full wp-image-156" title="object_sizes" src="{{ site.baseurl }}/assets/object_sizes.jpg" alt="" width="823" height="682" /></a></p>
<p>Mais la concomitance de ses demandes d'allocation avec l'utilisation de la heap fait sourciller.</p>
<p>On continue</p>
<blockquote><p>Garbage collection is causing some large pauses. The largest pause was 7362 ms. This may affect application responsiveness. If responsiveness is a concern then a switch of policy or reduction in heap size may be helpful.</p></blockquote>
<p>Effectivement le temps passé dans l'application et le temps passé dans le GC indique manifestement qu'il y a une suractivité anormale du GC.</p>
<p><a href="http://www.blog2.arkey.fr/wp-content/uploads/2010/07/compaction_pauses.jpg"><img class="alignnone size-full wp-image-157" title="compaction_pauses" src="{{ site.baseurl }}/assets/compaction_pauses.jpg" alt="" width="823" height="682" /></a></p>
<p>En fait on voit même que le GC est en train de compacter la mémoire au moment  de l'incident, c'est la courbe rouge clair (entre ~0.5s et 1s), ajouté à cela le temps de marquage des objets à virer (<em>bon en fait dans le graphique que j'ai fait, le temps de pause est principalement du au temps de marquage</em>), l'ensemble donnant un temps de pause pour laisser le GC travailler allant de 1 à 7s (par GC bien évidement).</p>
<p>Et là effectivement expliquer les ralentissements de l'application devient plus facile, merci à ces beaux graphiques explicites.</p>
<p>On peut regarder vraiment beaucoup de chose avec cet outils, même s'il y a des défauts manifestes dans l'interface utilisateur. C'est quand même plutôt pas mal.</p>
<p>Je termine sur un petit résumé des valeurs intéressantes que nous donne cet outils.</p>
<blockquote>
<table style="width: 400px; height: 200px; background-color: #000000; border: 1px solid #000000;" border="1" cellspacing="1" cellpadding="2">
<tbody>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">Allocation failure count</td>
<td style="background-color: white; border-width: medium; border-style: none;">59971</td>
</tr>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">Forced collection count</td>
<td style="background-color: white; border-width: medium; border-style: none;">3</td>
</tr>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">GC Mode</td>
<td style="background-color: white; border-width: medium; border-style: none;"><span style="background-color: #ffff99;">optthruput</span></td>
</tr>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">Largest memory request (bytes)</td>
<td style="background-color: white; border-width: medium; border-style: none;">5242904</td>
</tr>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">Mean garbage collection pause (ms)</td>
<td style="background-color: white; border-width: medium; border-style: none;">491</td>
</tr>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">Mean heap unusable due to fragmentation (MB)</td>
<td style="background-color: white; border-width: medium; border-style: none;">0.2</td>
</tr>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">Mean interval between collections (minutes)</td>
<td style="background-color: white; border-width: medium; border-style: none;"><span style="background-color: #ffff99;">0.01</span></td>
</tr>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">Number of collections</td>
<td style="background-color: white; border-width: medium; border-style: none;">59974</td>
</tr>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">Proportion of time spent in garbage collection pauses (%)</td>
<td style="background-color: white; border-width: medium; border-style: none;"><span style="background-color: #ffff99;">58.24</span></td>
</tr>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">Proportion of time spent unpaused (%)</td>
<td style="background-color: white; border-width: medium; border-style: none;"><span style="background-color: #ffff99;">41.76</span></td>
</tr>
<tr>
<td style="background-color: white; border-width: medium; border-style: none;">Rate of garbage collection (MB/minutes)</td>
<td style="background-color: white; border-width: medium; border-style: none;"><span style="background-color: #ffff99;">13250</span></td>
</tr>
</tbody>
</table>
</blockquote>
<p>Tiens le mode GC est optthruput, en fait c'est une des polices du comportement du GC, et probablement de la manière de segmenter la mémoire (Nursery (Young), Old (Tenured)).</p>
<p>En effet dans les logs GC, je n'ai pratiquement vu que des GC globaux et uniquement sur la section de la tenured, à priori pas de zone nursery, c'est probablement du à ce comportement du GC.</p>
<p>En me renseignant donc, il y a 4 polices de GC dans la JVM J9 de IBM :</p>
<ul>
<li><strong>optthruput</strong> : Optimisé pour throughput (le débit), flat heap <strong>&lt;= Bingo</strong></li>
<li><strong>optavgpause</strong> : Optimisé pour les temps de pause (Stop-The-World), le CMS est configuré pour prendre le moins de temps, flat heap</li>
<li><strong>subpool</strong> : Un police optimisé pour les machine multi-processeur, flat heap</li>
<li><strong>gencon</strong>: C'est le GC générationnel, qui est divisé en zone
<ul>
<li>nursery : qui permet la collection rapide et efficace des objets de vie courte, pas de pause</li>
<li>tenured : zone des vieux objets, mais un GC dans cette zone est global et demande à pauser l'application</li>
</ul>
</li>
</ul>
<h1>A la poursuite du vrai problème (partie 2)</h1>
<h2>La pèche aux informations</h2>
<p>Après avoir passé le GC au mode générationnel, il y a toujours ces problèmes de lenteurs mais ce n'est plus généralisé à toute l'appli, pas de log GC pour vérifier mais Introscope indique une utilisation relativement correcte de la mémoire, bizarre. Back to basics!</p>
<p>Le thread dump de la JVM IBM me dit toujours que la Heap est utilisée à 100%, mais je vois quand même</p>
<blockquote><p>Free Java heap size: 72 041 864 bytes</p>
<p>Allocated Java heap size: 402 653 184 bytes</p></blockquote>
<p>Et plus loin :</p>
<pre class="lang:default decode:true ">Last Garbage Collection Detail

Nursery Area Free : 59 307 392 bytes Total : 60 397 568 bytes 98 % free
Tenured Area Free : 17 058 368 bytes Total : 335 544 320 bytes 5% free
Global Garbage Collector Counter : 148</pre>
<p>La tenured est bien remplie et utilise un très grosse partie de la heap ; memory leak ou beaucoup d'objet à mettre en cache. Ou encore autre chose, sans mesures claires pour écarter les hypothèses ces dur.</p>
<p>Pour quoi ne pas <strong>activer dans tous les cas le log GC</strong>, la JVM IBM offre des option pour gérer la rotation des logs GC, comme ça l'argument de saturation du disque tombe à l'eau. Mais bon il faut lire la documentation; donc petit passage chez IBM grâce à Google, et hop :</p>
<pre class="lang:sh decode:true">-Xverbosegclog[:&lt;file&gt;[,&lt;x&gt;,&lt;y&gt;]]</pre>
<p>Et voilà : <strong>file</strong> étant le couple chemin + fichier, <strong>X</strong> le nombre de fichier maximum (ça tourne et écrase les fichiers), <strong>Y</strong> le nombre de cycle GC. Ce que ne dis pas par contre la doc IBM c'est la taille approximative d'un GC, donc 700 cycles de GC ≃ 1 MB. Il est même possible d'utiliser des tokens utilisés pour les dumps dans WAS 7 (voir <a href="http://www-01.ibm.com/support/docview.wss?rs=180&amp;context=SSEQTP&amp;dc=DB560&amp;dc=DB520&amp;uid=swg21384096&amp;loc=en_US&amp;cs=UTF-8&amp;lang=en&amp;rss=ct180websphere">ici</a>).</p>
<h2>Recoupement des informations</h2>
<p>Le log du Garbage Collector ne venant pas, il faut chercher autrement. Je demande au moment ou le problème se reproduit , de faire plusieurs thread dump d'affilé séparé de quelques secondes (~20s) et de faire également un listing des sous-processus java.</p>
<p>En effet le thread dump est bien sympa, mais il ne donne pas la consommation CPU des threads.</p>
<p>Dans un environnement il faut entre dans le terminal (Dans Linux l'identifiant des thread est dans la colonne LWD.) :</p>
<pre class="lang:sh decode:true">ps -fLp &lt;processid&gt; -L</pre>
<p>Evidement il s'agit d'un AIX et les commendes sont différents, pas de soucis un petit tour dans la doc IBM et il faut entrer la commande suivante, et là l'identifiant de la thread est dans la colonne TID :</p>
<pre class="lang:sh decode:true ">ps -mp -o THREAD</pre>
<p>On a alors un listing énorme, que j'ai tronqué ici.</p>
<pre class="lang:default mark:2,8 decode:true ">USER    PID   PPID       TID S  CP PRI SC    WCHAN        F     TT BND COMMAND
wasadmin 393262 401580         - A 188  60 203        *   202001      -   - /opt/was61/java/bin/java ...
 -      -      -    700535 S   0  82  1 f100070f1000ab40  8410400      -   - -
 -      -      -    741581 S   0  82  1 f100070f1000b540  8410400      -   - -
 -      -      -    802997 S   0  82  1 f100070f1000c440  8410400      -   - -
 -      -      -    884895 S   0  82  1 f100070f1000d840  8410400      -   - -
 -      -      -   1183791 Z   0  82  1         -       c00001         -   - -
 -      -      -   1667157 R  60 122  0            -    400000       -   - -
 -      -      -   1708269 S   0  82  1 f100070f1001a140  8410400      -   - -
 -      -      -   1736831 S   0  82  1 f100070f1001a840  8410400      -   - -</pre>
<p>La colonne CP me dit que manifestement la thread <strong>1667157</strong> utilise plutôt pas mal le CPU, qu'est-ce que donne cette thread du coté du thread dump ?! Au fait on repère 3 threads dans le même cas.</p>
<p>Il faut savoir que dans le thread dump il y a l'identifiant de la thread en Java, mais qu'il y a aussi et surtout de mentionné l'identifiant natif de la thread, par exemple <strong>NID</strong>.</p>
<p>Je google "<strong>1667157 in hex</strong>" ce qui me renvoie <strong>0x197055</strong>. En utilisant l'outils IBM mentionné plus haut, on voit clairement que la thread en cause correspond à du code métier, développé ici.</p>
<p><a href="http://www.blog2.arkey.fr/wp-content/uploads/2010/08/tdump-cause2.png"><img class="alignnone size-full wp-image-200" title="tdump-cause" src="{{ site.baseurl }}/assets/tdump-cause2.png" alt="" width="1103" height="700" /></a></p>
<p>Chacune des 3 threads passent dans le même bout de code. Autant au début j'ai des doutes, après toute la présomption d'innocence compte aussi pour le code, d'autant plus qu'il s'agit d'un code lent qui utilise beaucoup de reflection. Mais faut prendre en compte aussi le fait que la pile descend à chaque fois dans la couche Hibernate, ça vaut le coup d'aller voir. Les développeurs qui connaissent un peu mieux le code poussent dans cette direction.</p>
<p>Entre temps les DBA confirme que la base de données réponds très bien, mais qu'elle enregistre un très fort nombre d'un certain type de requête SQL.</p>
<p>Bingo, il y a une race condition dans une des boucles, et celle-ci part en boucle infinie. Ceci explique la très forte utilisation de la mémoire et les lenteurs remarquées.</p>
<h1>Bilan</h1>
<p>Un problème peut en cacher un autre, ou plus exactement un problème peut en provoquer d'autres. Il faut juste avoir des moyens de mesurer les changements qu'on apporte si on veut isoler / écarter des catégorie de problèmes.</p>
<p>L'outillage on l'a vu est essentiel, Introscope apporte des choses, mais il ne permet pas tout. Qui plus est, on ne sait pas précisément ce qu'il mesure et ou! Les temps de réponses SQL, n'étaient par exemple pas crédible, car Introscope mesurait également les GC.</p>
<p>Dans notre cas ici, j'aurais aussi bien aimé avoir une JVM IBM sur mon poste histoire de jouer plus facilement avec. C'est dommage que IBM ne fournisse pas gratuitement sa JVM au moins pour le développement.</p>
<p>Accessoirement ce serait bien un jour d'avoir des format de log normalisé entre les JVM, ainsi que certaines des options afférentes.</p>
<p>Finalement ce qui a pris le plus de temps était d'obtenir les bonnes données, pour prendre les meilleurs choix. L'impression de travailler les mains dans le noir n'était pas l'idéal pour résoudre le problème, mais c'est au moins formateur. Je peux dire que j'ai bien apprécié certains retours et recommandations des  développeurs. L'équipe système étant surchargée n'a pas pu nous donné un support optimal, et cette carence s'est ressentie notamment pour avoir les données à temps. Mais leur vu du problème a permis d'orienter la recherche sur les parties qui pouvait poser problème.</p>
<h1>Références &amp; Documentation</h1>
<ul>
<li><a href="http://websphere.sys-con.com/node/921279?page=0,1">http://websphere.sys-con.com/node/921279?page=0,1</a></li>
<li><a href="http://sites.google.com/site/threaddumps/java-thread-dumps">http://sites.google.com/site/threaddumps/java-thread-dumps</a></li>
<li><a href="http://java.sun.com/developer/technicalArticles/Programming/Stacktrace/">http://java.sun.com/developer/technicalArticles/Programming/Stacktrace/</a></li>
<li><a href="http://geekexplains.blogspot.com/2008/07/threadstate-in-java-blocked-vs-waiting.html">http://geekexplains.blogspot.com/2008/07/threadstate-in-java-blocked-vs-waiting.html</a></li>
<li><a href="http://www.ibm.com/developerworks/java/library/j-nativememory-aix/">http://www.ibm.com/developerworks/java/library/j-nativememory-aix/</a></li>
<li><a href="http://www.ibm.com/developerworks/ibm/library/i-garbage1/">http://www.ibm.com/developerworks/ibm/library/i-garbage1/</a></li>
<li><a href="http://www-01.ibm.com/support/docview.wss?rs=180&amp;context=SSEQTP&amp;dc=DB560&amp;dc=DB520&amp;uid=swg21384096&amp;loc=en_US&amp;cs=UTF-8&amp;lang=en&amp;rss=ct180websphere">http://www-01.ibm.com/support/docview.wss?rs=180&amp;context=SSEQTP&amp;dc=DB560&amp;dc=DB520&amp;uid=swg21384096&amp;loc=en_US&amp;cs=UTF-8&amp;lang=en&amp;rss=ct180websphere</a></li>
<li><a href="http://publib.boulder.ibm.com/infocenter/javasdk/v6r0/index.jsp?topic=/com.ibm.java.doc.diagnostics.60/diag/appendixes/cmdline/cmdline_gc.htm">http://publib.boulder.ibm.com/infocenter/javasdk/v6r0/index.jsp?topic=/com.ibm.java.doc.diagnostics.60/diag/appendixes/cmdline/cmdline_gc.htm</a></li>
</ul>
